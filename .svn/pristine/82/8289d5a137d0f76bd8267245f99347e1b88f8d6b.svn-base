<template>
  <!-- ìš°ì¸¡ ë©”ë‰´ -->
  <!--<ion-router-outlet id="main-content"></ion-router-outlet>-->

  <ion-page>
    <ion-menu side="end" content-id="main-content">
      <ion-header class="ion-padding pb-0" style="margin-top: 30px">
        <ion-list lines="full" class="message-talk-info">
          <ion-item-group>
            <ion-item
              v-if="
                this.messageType == 'message' && this.chatroomType == 'openchat'
              "
            >
              <ion-label>
                <ion-text
                  class="text-pink text-bold text-sm"
                  @click="openUseOpenChatModal"
                  >í˜„ì¬ {{ openchatRank }}ìœ„ ëª¨ì„ ğŸ”¥
                </ion-text>
                <h3>
                  <ion-text color="light" class="text-bold text-xl"
                    >{{ title }}
                  </ion-text>
                </h3>
                <ion-text
                  color="light"
                  class="text-sm"
                  v-if="this.chatroomType == 'openchat'"
                >
                  <ion-label>{{ talkUserCnt }} / 300ëª…</ion-label>
                </ion-text>
              </ion-label>
              <!--              <ion-icon-->
              <!--                slot="end"-->
              <!--                color="light"-->
              <!--                :icon="notificationShakeIcon"-->
              <!--              />-->
              <ion-icon
                slot="end"
                color="light"
                :icon="alarmCheck ? notifications : notificationsOff"
                @click="alarmCheckBtn"
              />
            </ion-item>
            <ion-item v-if="chatroomType != 'anonymous'">
              <ion-row
                class="ion-align-items-center ion-justify-content-between gap-sm w-full flex-nowrap"
              >
                <ion-buttons>
                  <ion-button
                    fill="outline"
                    shape="round"
                    color="primary"
                    class="mt-2 mb-2"
                    @click="goRouter('map', this.chatroomId)"
                  >
                    <ion-icon
                      slot="start"
                      color="light"
                      :icon="mapOutline"
                      size="small"
                    />
                    <ion-text color="light"> ì§€ë„ì—ì„œ ë³´ê¸°</ion-text>
                  </ion-button>
                </ion-buttons>
                <div>
                  <ion-item
                    lines="none"
                    v-for="item in this.locationList"
                    v-show="this.SS_USER_KEY === item.userKey"
                    :key="item.userKey"
                    class="ion-align-items-center"
                  >
                    <ion-label>
                      <ion-text color="light" class="text-xs text-bold"
                        >ë‚´ ìœ„ì¹˜ê³µìœ 
                      </ion-text>
                    </ion-label>
                    <ion-toggle
                      slot="end"
                      :checked="this.toggleLocation"
                      class="v-middle"
                      mode="ios"
                      @click="setLocationYn"
                    ></ion-toggle>
                  </ion-item>
                </div>
              </ion-row>
            </ion-item>
          </ion-item-group>
        </ion-list>
      </ion-header>
      <ion-content class="ion-padding">
        <div class="row-box">
          <ion-list>
            <MessageTalkAttendList>
              <template #title>
                <ion-text>ì°¸ì—¬ì</ion-text>
              </template>
              <template #content>
                <ion-list
                  v-for="data in userRoomList"
                  :key="data.userId"
                  class="pt-0 pb-0"
                >
                  <MessageTalkAttendItem
                    :item="data"
                    :messageType="chatroomType !== 'openchat'"
                    :myCheck="this.SS_USER_KEY === data.userKey"
                    :id="'currentPopoverTrigger' + data.userId"
                  >
                  </MessageTalkAttendItem>
                  <ion-popover
                    :trigger="'currentPopoverTrigger' + data.userId"
                    :dismiss-on-select="true"
                    mode="ios"
                    v-if="
                      chatroomType != 'anonymous' ||
                      this.SS_USER_KEY !== data.userKey
                    "
                  >
                    <ion-content>
                      <ion-list lines="full">
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('profile', data)"
                          v-if="chatroomType != 'anonymous'"
                          >í”„ë¡œí•„ë³´ê¸°
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('kick', data)"
                          v-show="
                            leaderYn == 'Y' &&
                            chatroomType == 'openchat' &&
                            ((this.SS_USER_KEY === data.leaderUserKey &&
                              this.SS_USER_KEY !== data.userKey &&
                              data.subLeaderYn === 'N') ||
                              (data.subLeaderYn === 'N' &&
                                data.leaderNum === 1))
                          "
                          >ê°•í‡´í•˜ê¸°
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('change', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey
                          "
                          >ë°©ì¥ìœ„ì„
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('subChange', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey &&
                            data.subLeaderYn === 'N'
                          "
                          >ë¶€ë°©ì¥ìœ„ì„
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('subRemoval', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey &&
                            data.subLeaderYn === 'Y'
                          "
                          >ë¶€ë°©ì¥í•´ì œ
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('police', data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          >ì‹ ê³ í•˜ê¸°
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="setBlock(data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          v-if="chatroomType == 'openchat'"
                          >ì°¨ë‹¨í•˜ê¸°
                        </ion-item>
                      </ion-list>
                    </ion-content>
                  </ion-popover>
                </ion-list>
              </template>
            </MessageTalkAttendList>
          </ion-list>
        </div>
        <div class="row-box">
          <ion-list v-if="leaderYn === 'Y' && chatroomType != 'single'">
            <MessageTalkAttendList>
              <template #title>
                <ion-text>ì°¸ì—¬ ì‹ ì²­ì</ion-text>
                <ion-text class="text-sub01"
                  >{{ attendList.length }}ëª…
                </ion-text>
              </template>
              <template #actions>
                <!--                <ion-text class="text-link text-sm sub-text01 text-bold"-->
                <!--                >ì¼ê´„ìˆ˜ë½-->
                <!--                </ion-text>-->
              </template>
              <template #content>
                <ion-list
                  v-for="data in attendList"
                  :key="data.userId"
                  class="pt-0 pb-0"
                >
                  <MessageTalkAttendItem
                    :item="data"
                    :id="'currentPopoverTrigger' + data.userId"
                  >
                    <template #actions>
                      <custom-button
                        fill="outline"
                        color="success"
                        size="small"
                        shape="round"
                        @click.stop="agreeYn('Y', data)"
                        >ìˆ˜ë½
                      </custom-button>
                      <custom-button
                        fill="outline"
                        color="danger"
                        size="small"
                        shape="round"
                        @click.stop="agreeYn('N', data)"
                        >ê±°ì ˆ
                      </custom-button>
                    </template>
                  </MessageTalkAttendItem>
                  <ion-popover
                    :trigger="'currentPopoverTrigger' + data.userId"
                    :dismiss-on-select="true"
                    mode="ios"
                  >
                    <ion-content>
                      <ion-list lines="full">
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('profile', data)"
                          >í”„ë¡œí•„ë³´ê¸°
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('kick', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey
                          "
                          >ê°•í‡´í•˜ê¸°
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('police', data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          >ì‹ ê³ í•˜ê¸°
                        </ion-item>
                      </ion-list>
                    </ion-content>
                  </ion-popover>
                </ion-list>
              </template>
            </MessageTalkAttendList>
          </ion-list>
        </div>
      </ion-content>

      <ion-footer>
        <!-- ì—…ì†Œ í™ë³´ ë°°ë„ˆ -->
        <MessageTalkAddBanner @click="goRouter('partnersMap')" />
        <p class="text-right">
          <ion-text class="text-link text-sm" color="light" @Click="chatRoomOut"
            >ì±„íŒ… ë‚˜ê°€ê¸°
          </ion-text>
        </p>
      </ion-footer>
    </ion-menu>

    <ion-page id="main-content">
      <ion-header>
        <ion-toolbar>
          <ion-buttons slot="start">
            <BackButton @event="goRouter('back')" :custom="true" />
          </ion-buttons>
          <ion-title>{{ title }}</ion-title>
          <ion-buttons slot="end">
            <ion-menu-button @click="menuBtn">
              <ion-icon :icon="menuIcon" color="light" />
            </ion-menu-button>
          </ion-buttons>
        </ion-toolbar>
      </ion-header>
      <ion-content ref="msgContainer" class="ion-padding important-height">
        <div
          v-if="
            this.messageType == 'message' && this.chatroomType == 'openchat'
          "
          class="custom-fixed"
          @click="openUseOpenChatModal"
        >
          <ion-img
            :src="'https://cmdg.speedycdn.net/202308/20230808143353_5905a0f6-1461-4d41-ac99-6b4c8c41dd0d.png'"
            style="width: 35px; height: 35px"
          />
          <ion-text color="light" class="text-bold text-lg">
            &nbsp;TOP {{ openchatRank }}
          </ion-text>
        </div>
        <ion-infinite-scroll
          threshold="100px"
          @ionInfinite="ionInfinite"
          position="top"
        >
          <ion-infinite-scroll-content
            loadingText="Please wait..."
            loadingSpinner="bubbles"
          ></ion-infinite-scroll-content>
        </ion-infinite-scroll>

        <ion-label ref="msgArea">
          <div v-for="item in messageTalkList" v-bind:key="item.messageId">
            <!--ìƒëŒ€ë°©-->
            <template
              v-if="
                this.SS_USER_KEY !== item.regUserKey && item.messageType !== 'Y'
              "
            >
              <!--@onImgDidLoad="scrollToBottom(item)"-->
              <!--@ionScroll="handleScroll($event)"-->
              <MessageTalkItem
                :item="item"
                :chatroomType="chatroomType"
                @zoomImg="openZoomedImage(item.cdnNmImage)"
              />
            </template>
            <!--ë‚˜-->
            <template
              v-if="
                this.SS_USER_KEY === item.regUserKey && item.messageType !== 'Y'
              "
            >
              <!--@onImgDidLoad="scrollToBottom(item)"-->
              <MessageTalkItem
                :type="true"
                :item="item"
                :chatroomType="chatroomType"
                @zoomImg="openZoomedImage(item.cdnNmImage)"
              />
            </template>

            <MessageTalkLabel
              :message="item.message"
              v-if="item.messageType === 'Y'"
            />
          </div>
        </ion-label>
      </ion-content>
      <!-- TODO : ì»¤ë®¤ë‹ˆí‹° ëŒ“ê¸€ í¼ê³¼ êµ¬ì¡°ê°€ ë‹¬ë¼ì„œ ê°œë°œ ë¡œì§ í†µì¼ í•„ìš” -->
      <ion-footer @keyup.enter="checkContent" class="no-padding">
        <!--@input="limitComment($event)"-->
        <MessageTalkSendForm
          v-model:value="content"
          :newimgFileId="imgCdnNm"
          :newimgViewFileId="imgCdnNm"
          :emoticonList="emoticonList"
          @handleAddPhoto="addPhoto()"
          @sendComment="send('chat')"
          @emoticonClick="emoticonClick"
          @handleEmoji="handleEmoji"
        />
        <input
          type="file"
          @change="onFileChange"
          ref="photo"
          class="is-blind"
        />
      </ion-footer>
    </ion-page>
    <!-- í—ˆë‹ˆë¶€ìŠ¤íŠ¸ ëª¨ë‹¬ì°½ ì‹œì‘ -->

    <!-- ê°•í‡´ ëª¨ë‹¬  -->
    <UserKickModal
      :is-open="modalMessage"
      @ionModalDidDismiss="modalMessage = false"
      @ok="modalBtn('save')"
      @cancel="modalBtn('cancel')"
    />

    <!-- ëª¨ì„ë¶€ìŠ¤íŠ¸ ëª¨ë‹¬ì°½ ì‹œì‘ -->
    <CustomBoostModal
      :is-open="boostModal"
      :isBuffYn="isBuffYn"
      :coupon="coupon"
      :openchatRank="openchatRank"
      :totalRoom="totalRoom"
      :useCnt="useCnt"
      :calTimeStr="calTimeStr"
      @ionModalDidDismiss="boostModalClose"
      @close="boostModalClose"
      @event="useOpenChatBoost"
    />
    <AlertMessageModal
      :is-open="messageTalkModal"
      :title="'ì±„íŒ…ë°© ë‚˜ê°€ê¸°'"
      :message="
        chatRoomLeaderYn == 'Y' && leaderCanOutYn == 'N'
          ? 'ë°©ì¥ì€ í˜¼ì ë‚¨ì€ ê²½ìš°ì—ë§Œ ë‚˜ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
          : 'ë‚˜ê°€ê¸°ë¥¼ í•˜ë©´ ëŒ€í™”ë‚´ìš©ì´ ëª¨ë‘ ì‚­ì œë˜ê³  ì±„íŒ…ëª©ë¡ì—ì„œë„ ì‚­ì œë©ë‹ˆë‹¤.'
      "
      :subMessage="''"
      :btnName="'ë‚˜ê°€ê¸°'"
      :height="210"
      :disabledCheck="chatRoomLeaderYn == 'Y' && leaderCanOutYn == 'N'"
      @ionModalDidDismiss="messageTalkModal = false"
      @handleClickBtn="roomExit"
    />
  </ion-page>
</template>

<script>
import { flameOutline, mapOutline } from 'ionicons/icons';
import {
  IonMenu,
  IonToggle,
  IonMenuButton,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  loadingController,
  alertController
} from '@ionic/vue';
import {
  getData,
  SS_USER_SEQ,
  API_BASE_URL,
  SS_USER_KEY,
  setFile,
  dailyCardInfoMapFn,
  messageTalkMapFn,
  messageTalkMap,
  policeMapFn,
  currentMsgHeightCalc,
  currentMsgHeightCalcFn,
  openChatViewMap,
  openChatMeetMap,
  openChatMeetMapFn,
  openChatViewMapFn
} from '@/assets/js/common';

import SockJS from 'sockjs-client';
import Stomp from 'webstomp-client';
import Hammer from 'hammerjs';

import MessageTalkItem from '@/components/MessageTalk/MessageTalkItem.vue';
import MessageTalkLabel from '@/components/MessageTalk/MessageTalkLabel.vue';
import MessageTalkSendForm from '@/components/MessageTalk/MessageSendForm.vue';
import MessageTalkAttendList from '@/components/MessageTalk/MessageTalkAttendList.vue';
import MessageTalkAttendItem from '@/components/MessageTalk/MessageTalkAttendItem.vue';
import MessageTalkAddBanner from '@/components/MessageTalk/MessageTalkAddBanner.vue';
import UserKickModal from '@/components/Modal/UserKickModal.vue';
import CustomBoostModal from '@/components/Custom/CustomBoostModal.vue';

import IconMenu from '@/assets/img/icon/icon_menu.svg';
import IconNotificationShake from '@/assets/img/icon/icon_notification_shake.svg';
import IconNotifications from '@/assets/img/icon/icon_notifications.svg';
import IconNotificationsOff from '@/assets/img/icon/icon_notifications_off.svg';

//import { Keyboard } from '@capacitor/keyboard';

import {
  CapacitorSQLite,
  SQLiteConnection,
  SQLiteDBConnection
} from '@capacitor-community/sqlite';
import AlertMessageModal from '@/components/Modal/AlertMessageModal.vue';
import { Camera, CameraResultType, CameraSource } from '@capacitor/camera';

import { Capacitor } from '@capacitor/core';
import { MarkerClustering } from '@/assets/js/MarkerClustering';

export default {
  name: 'MessageTalk',
  inject: ['loadingController', 'alertController'],
  components: {
    AlertMessageModal,
    IonInfiniteScroll,
    IonInfiniteScrollContent,
    MessageTalkItem,
    MessageTalkLabel,
    MessageTalkSendForm,
    MessageTalkAttendList,
    MessageTalkAttendItem,
    MessageTalkAddBanner,
    IonMenu,
    IonToggle,
    IonMenuButton,
    UserKickModal,
    CustomBoostModal
  },
  computed: {
    messageTalkList() {
      //storex ê°ì‹œ
      return this.$store.state.messageList;
    }
  },
  watch: {
    messageTalkList: {
      deep: true,
      handler() {
        //computed messageTalkListê°€ ë³€í˜•ë ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
        if (this.currentMsgHeightCalc <= 350) {
          this.scrollToBottom();
        }
      }
    }
  },
  data() {
    return {
      menuIcon: IconMenu,
      notificationShakeIcon: IconNotificationShake,
      notifications: IconNotifications,
      notificationsOff: IconNotificationsOff,
      mapOutline,
      flameOutline,
      API_BASE_URL,
      SS_USER_KEY,
      chatroomId: '',
      messageType: '',
      chatroomType: '',
      loginSeq: SS_USER_SEQ,
      userSeq: '',
      userPhoto: null,
      userNick: '',
      lastSearchTime: '',
      chatBeforeList: [],
      chatList: [],
      content: '',
      container: this.$refs.msgContent,
      stompClient: '',
      connected: false,
      interval: null,
      isFirst: true,
      Attachfiles: [],
      imgFileId: '',
      imgCdnNm: '',
      loading: null,
      isZoomed: false,
      selectType: 'first',
      nextNo: 0,
      userRoomList: [],
      attendList: [],
      showUserList: false,
      showProfileOptions: false,
      currentNick: '',
      title: '',
      talkUserCnt: 0,
      leaderYn: '',

      interval2: null,
      interval3: null,
      interval4: null,
      boostModal: false,
      openchatRank: 0,
      openChatKey: '',
      totalRoom: 0,
      isBuffYn: 'N',
      useCnt: 0,
      calTimeStr: '',
      coupon: {},
      useType: 'HEART',

      modalMessage: false,
      locationList: '',
      currentMsgHeightCalc: 0,
      targetUserKey: '',
      targetUserType: '',
      toggleLocation: false,
      alarmCheck: true,
      emoticonList: [],
      emojiCheck: false,

      isEndScroll: false,
      messageTalkModal: false,
      chatRoomLeaderYn: 'N',
      leaderCanOutYn: 'N',
      isChatBlock: false
    };
  },
  ionViewWillEnter() {
    this.selectType = 'first';
    this.nextNo = 0;
    this.isEndScroll = false;
    this.chatRoomLeaderYn = 'N';
    this.leaderCanOutYn = 'N';
    // ì§„ì…í•  ë•Œ í˜¸ì¶œ
    this.chatroomId = messageTalkMap.chatroomId;
    this.messageType = messageTalkMap.type;
    // this.chatroomType = messageTalkMap.chatroomType;
    if (this.$store.state.currentChatroomId != messageTalkMap.chatroomId) {
      this.$store.state.currentChatroomId = messageTalkMap.chatroomId;
      this.$store.state.messageList = [];
    }
    //ì†Œì¼“ì—°ê²°
    /*this.$nextTick(() => {
      this.connect();
      this.isFirst = false;
    });*/

    //ì ‘ì†ìƒíƒœë¥¼ ê°ì‹œí•´ì„œ ì—°ê²°ì´ ëŠì–´ì§ˆê²½ìš° ì¬ì ‘ì†í•œë‹¤ (1ì´ˆë°˜ë³µ)
    /*this.interval = setInterval(() => {
      if (!this.isFirst && !this.connected) {
        this.connect();
      }
    }, 500);*/

    this.getChatRoomType();

    this.chatBlock();
  },
  ionViewDidLeave() {
    // ë– ë‚  ë•Œ í˜¸ì¶œ
    /*clearInterval(this.interval);*/
    clearInterval(this.interval2);
    clearInterval(this.interval3);
    clearInterval(this.interval4);
    //this.stompClient.disconnect(function () {});
    this.isFirst = true;
  },
  mounted() {},
  methods: {
    /** ë°©ì¥ or ë¶€ë°©ì¥ ì²´í¬ **/
    getLeaderCheck() {
      getData({
        url: '/getLeaderCheck',
        param: {
          chatroomId: this.chatroomId,
          openChatKey: this.openChatKey
        },
        then: (data) => {
          this.leaderYn = data.leaderYn;
        }
      });
    },

    chatRoomOut() {
      if (this.chatroomType == 'openchat') {
        if (this.chatRoomLeaderYn == 'Y') {
          if (this.userRoomList.length <= 1) {
            this.leaderCanOutYn = 'Y';
          } else {
            this.leaderCanOutYn = 'N';
          }
        }
      } else {
        this.leaderCanOutYn = 'Y';
      }

      this.messageTalkModal = true;
    },

    roomLeaderExit() {
      getData({
        url: '/messageMain/setDropOutLeader',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          // this.$router.push("message");
          this.messageTalkModal = false;
          this.$router.go(-1);
        }
      });
    },
    handleEmoji() {
      this.$refs.msgContainer.$el.scrollToBottom(0);
    },
    getChatRoomType() {
      getData({
        url: '/messageMain/getChatRoomType',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.chatroomType = data.chatroomType;

          this.updateMessageRecept();
          this.getMessageList();

          this.getLocationListCheck();

          this.initSqlite();
          this.getEmoticonList();

          this.getChatroomTitle();
          this.getLocationYn();
        }
      });
    },
    emoticonClick(item) {
      this.content = item.emoticonNm;
      this.imgFileId = item.fileId;

      this.send('emoticon');
    },
    chatBlock() {
      getData({
        url: '/messageMain/chatBlock',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.isChatBlock = data.isBlock == 'Y' ? true : false;
        }
      });
    },
    /** ì´ëª¨í‹°ì½˜ **/
    getEmoticonList() {
      getData({
        url: '/messageMain/getEmoticonList',
        param: {},
        then: (data) => {
          this.emoticonList = data;
        }
      });
    },
    /** ì•ŒëŒ on/off **/
    alarmCheckBtn() {
      getData({
        url: '/messageMain/getChatRoomAlarm',
        param: { alarmCheck: this.alarmCheck, chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.getChatRoomAlarmList();
          }
        }
      });
    },
    /** ì•ŒëŒìƒíƒœ ì²´í¬ **/
    getChatRoomAlarmList() {
      getData({
        url: '/messageMain/getChatRoomAlarmList',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.alarmCheck = data.val === 'Y' ? true : false;
        }
      });
    },
    menuBtn() {
      this.getLeaderCheck();
      this.getUserList();
      this.getAttendList();
      this.getChatroomTitle();
      this.getChatRoomAlarmList();
    },

    handleScroll(ev) {
      console.log('scroll' + ev.detail);
    },
    async initSqlite() {
      const sqlite = new SQLiteConnection(CapacitorSQLite);
      if (Capacitor.getPlatform() === 'web') {
        const jeepSqlite = document.createElement('jeep-sqlite');
        document.body.appendChild(jeepSqlite);
        await customElements.whenDefined('jeep-sqlite');
        await sqlite.initWebStore();
      }
      let db;
      const ret = await sqlite.checkConnectionsConsistency();
      const isConn = (await sqlite.isConnection('navy')).result;
      if (ret.result && isConn) {
        db = await sqlite.retrieveConnection('navy');
      } else {
        db = await sqlite.createConnection('navy', false, 'no-encryption', 1);
      }
      await db.open();
      const res3 = await db.query('SELECT * FROM test');
      //console.log(res3.values);

      await sqlite.closeConnection('navy');
    },
    modalBtn(type) {
      if (type === 'save') {
        this.getKickUser();
      } else {
        this.modalMessage = false;
      }
    },

    openProfile(userId, userNick) {
      this.currentNick = userNick;
      this.showProfileOptions = true;
    },
    roomExit() {
      if (this.chatRoomLeader == 'Y' && this.leaderCanOutYn == 'Y') {
        this.roomLeaderExit();
      } else if (this.chatRoomLeader == 'Y' && this.leaderCanOutYn == 'N') {
        // í•´ë‹¹ ê²½ìš°ëŠ” ì—†ì–´ì•¼ ì •ìƒ
        this.warningAlert(
          'ì†Œëª¨ì„ì—ì„œ ë°©ì¥ì€ í˜¼ì ë‚¨ì€ ê²½ìš°ì—ë§Œ ë‚˜ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
        );
      } else {
        this.targetUserKey = this.SS_USER_KEY;
        this.targetUserType = 'self';
        this.getKickUser();
      }
    },
    getKickUser() {
      getData({
        url: '/messageMain/setDropOutUser',
        param: {
          chatroomId: this.chatroomId,
          userKey: this.targetUserKey,
          type: this.targetUserType
        },
        then: (data) => {
          if (data.successYn === 'Y') {
            if (this.targetUserType === 'kick') {
              this.userRoomList = data.roomUserList;

              this.getUserList();
              this.getAttendList();
              this.updateMessageRecept();
              this.modalMessage = false;
            } else if (this.targetUserType === 'self') {
              // this.$router.push("message");
              this.messageTalkModal = false;
              this.$router.go(-1);
            }
          } else {
            this.warningAlert(data.message);
          }
        }
      });
    },
    /*connect() {
      const serverURL = API_BASE_URL + '/commonSocket';
      let socket = new SockJS(serverURL);
      this.stompClient = Stomp.over(socket);
      console.log("ì†Œì¼“ ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤. ì„œë²„ ì£¼ì†Œ: " + serverURL);
      this.stompClient.connect(
        {},
        (frame) => {
          // ì†Œì¼“ ì—°ê²° ì„±ê³µ
          this.connected = true;
          console.log("ì†Œì¼“ ì—°ê²° ì„±ê³µ", frame);
          // ì„œë²„ì˜ ë©”ì‹œì§€ ì „ì†¡ endpointë¥¼ êµ¬ë…í•©ë‹ˆë‹¤.
          // ì´ëŸ°í˜•íƒœë¥¼ pub sub êµ¬ì¡°ë¼ê³  í•©ë‹ˆë‹¤.
          this.stompClient.subscribe("/channel/" + this.chatroomId, (res) => {
            // ë°›ì€ ë°ì´í„°ë¥¼ jsonìœ¼ë¡œ íŒŒì‹±í•˜ê³  ë¦¬ìŠ¤íŠ¸ì— ë„£ì–´ì¤ë‹ˆë‹¤
            this.messageTalkList.push(JSON.parse(res.body));
            this.scrollToBottom();
          });
          //ì†Œì¼“ì—°ê²°ì´ ì™„ë£Œëœ ì´í›„ ë°ì´í„°ë¥¼ ì¡°íšŒí•œë‹¤.
          //ë©”ì„¸ì§€ ì½ìŒ ì²˜ë¦¬
          this.updateMessageRecept();
          //ë©”ì„¸ì§€ ì¡°íšŒ
          this.getMessageList();
        },
        (error) => {
          // ì†Œì¼“ ì—°ê²° ì‹¤íŒ¨
          console.log("ì†Œì¼“ ì—°ê²° ì‹¤íŒ¨", error);
          this.connected = false;
        }
      );
    },*/
    /* ìŠ¤í¬ë¡¤ ë§¨ ì•„ë˜ë¡œ */
    scrollToBottom(item) {
      if (item !== undefined && item !== null) {
        item.isLoaded = true;
      }

      setTimeout(() => {
        this.$refs.msgContainer.$el.scrollToBottom(0);
      }, 100);
    },
    getMessageList() {
      let self = this;

      this.talkUserCnt = 0;
      if (this.selectType !== 'first' && this.nextNo === '0') {
        alert('ì‹œìŠ¤í…œì˜¤ë¥˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.');
        return;
      }

      clearInterval(this.interval4);

      getData({
        url: '/messageMain/getMessageList',
        param: {
          chatroomId: this.chatroomId,
          type: this.selectType,
          nextNo: this.nextNo
        },
        then: (data) => {
          this.$store.state.messageList = data;
          if (data.length > 0) {
            this.selectType = 'second';
            this.nextNo = data[0]['messageId'];
          }
          this.$nextTick(() => {
            //this.scrollToBottom();

            self.interval4 = setInterval(async () => {
              const elem = self.$refs.msgContainer.$el;
              const scrollElement = await elem.getScrollElement();
              let maxHeight = scrollElement.scrollHeight;
              let currentHeight = scrollElement.scrollTop + 736;
              let heightPx = maxHeight - currentHeight;

              self.$store.state.currentMsgHeightCalc = heightPx;
              self.currentMsgHeightCalc = heightPx;
            }, 2000);

            self.replaceURL();
          });
        }
      });
    },
    updateMessageRecept() {
      //ë©”ì‹œì§€ ì½ìŒì²˜ë¦¬
      getData({
        url: '/messageMain/updateMessageRecept',
        param: { chatroomId: this.chatroomId },
        then: () => {}
      });
    },

    /** ì±—ë°© ìœ ì €ë¦¬ìŠ¤íŠ¸ **/
    getUserList() {
      getData({
        url: '/messageMain/getRoomUserList',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          this.userRoomList = data;
          this.talkUserCnt = data.length;

          this.$nextTick(() => {
            this.getAttendList();
          });
        }
      });
    },
    getLocationListCheck() {
      getData({
        url: '/messageMain/getLocationListCheck',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          this.locationList = data;
        }
      });
    },
    getLocationYn() {
      getData({
        url: '/messageMain/getLocationYn',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.toggleLocation = data.locationYn == 'Y' ? true : false;
          }
        }
      });
    },
    setLocationYn() {
      getData({
        url: '/messageMain/setLocationYn',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.toggleLocation = data.updatedValue === 'Y' ? true : false;
          }
          this.getUserList();
        }
      });
    },
    /** ì±—ë°© ì‹ ì²­ìœ ì €ë¦¬ìŠ¤íŠ¸ **/
    getAttendList() {
      getData({
        url: '/messageMain/getAttendList',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.attendList = data;

          // this.$nextTick(() => {
          //   if (messageTalkMap.type != "message"
          //     || (messageTalkMap.type == "message" && messageTalkMap.chatroomType == "openchat")) {
          //     this.getChatroomTitle();
          //   }
          // });
        }
      });
    },

    getChatroomTitle() {
      getData({
        url: '/messageMain/getChatroomTitle',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.title = data.title ? data.title : 'ëŒ€í™”ìƒëŒ€ê°€ ì—†ìŠµë‹ˆë‹¤.';
          this.openchatRank = data.openchatRank;
          this.openChatKey = data.openChatKey;
          this.chatRoomLeaderYn = data.leaderYn;
        }
      });
    },

    /* ë¹ˆ ë¬¸ìì—´ì¸ì§€ ì•„ë‹Œì§€ ë¨¼ì € ì²´í¬í•˜ê¸° */
    checkContent(e) {
      /*if (this.content === null || this.content === '') {
        /!* ë¹ˆ ë¬¸ìì—´ì´ ë“¤ì–´ì˜¤ë©´ alertì°½ ë„ìš°ê¸°. *!/
        return;
      } else {
        /!* ë¹ˆë¬¸ìì—´ì´ ì•„ë‹ˆë©´ ë‚´ìš© ë³´ë‚´ê¸° *!/
        this.send('chat');
      }*/
    },

    /* ë©”ì„¸ì§€ ì „ì†¡ */
    send(type) {
      //if (this.stompClient && this.stompClient.connected) {
      //const msg = { name: this.send_message };
      //this.stompClient.send("/app/hello", JSON.stringify(msg), {});
      if (this.isChatBlock) {
        this.warningAlert(
          'ì‚­ì œëœ ì†Œëª¨ì„ì…ë‹ˆë‹¤.<br />ì‚­ì œëœ ê¸€ì—ëŠ” ë” ì´ìƒ ì±„íŒ…ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
        );
        return;
      }

      if (
        type !== 'emoticon' &&
        type !== 'image' &&
        (this.content === null || this.content === '')
      ) {
        this.warningAlert('ë³´ë‚¼ ë©”ì„¸ì§€ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”');
        return;
      }

      if (type !== 'image' && type !== 'emoticon') {
        this.imgFileId = '';
        this.imgCdnNm = '';
      }
      getData({
        url: '/messageMain/sendMessageSingle',
        param: {
          chatroomId: this.chatroomId,
          message: this.content,
          type: type,
          fileId: this.imgFileId
        },
        then: (res) => {
          if (res.successYn == 'N') {
            this.warningAlert(res.message);
          } else {
            this.imgFileId = '';
            this.imgCdnNm = '';
            this.messageTalkList.push(res);
            this.scrollToBottom();
          }

          this.$nextTick(() => {
            this.replaceURL();
          });
        }
      });
      //}

      //inputì°½ ë¦¬ì…‹
      this.content = '';
    },

    replaceURL() {
      //ì°¨ë‹¨ëœ ì‚¬ìš©ì ë©”ì‹œì§€ ì œê±°
      /*let localStorageBlockList = JSON.parse(
        localStorage.getItem(this.openChatKey)
      );*/

      let regexp = /(?:http(s?)?|www)\S+\w/g;
      Array.from(this.messageTalkList).forEach((message, index) => {
        let _match = message.message.match(regexp);
        let match = [...new Set(_match)];
        this.messageTalkList[index]['replaceMessage'] = message.message;
        Array.from(match).forEach((item) => {
          if (!item.includes('http')) {
            this.messageTalkList[index]['replaceMessage'] =
              this.messageTalkList[index]['replaceMessage'].replaceAll(
                item,
                `<a href="http://${item}" target="_blank">${item}</a>`
              );
          } else {
            this.messageTalkList[index]['replaceMessage'] =
              this.messageTalkList[index]['replaceMessage'].replaceAll(
                item,
                `<a href="${item}" target="_blank">${item}</a>`
              );
          }
        });
      });
    },

    addPhoto() {
      /** ì‚¬ì§„ì²© í˜¸ì¶œ & íŒŒì¼ê°ì²´ ë³€í™˜ **/
      Camera.getPhoto({
        allowEditing: false, //ì‚¬ì§„ìˆ˜ì •ì—¬ë¶€ (ì•ˆë“œë¡œì´ë“œë§Œ ê°€ëŠ¥, IOSëŠ” ì¹´ë©”ë¼ ì´¬ì˜ì‹œë§Œ ìˆ˜ì •)
        source: CameraSource.Photos, //ì‚¬ì§„ì²¨, ì´¬ì˜, ë“± ì„¤ì •
        resultType: CameraResultType.Uri //ì‚¬ì§„ result Type
      }).then(async (photo) => {
        let blob = await fetch(photo.webPath).then((r) => r.blob());
        const file = new File([blob], 'fileName.' + photo.format, {
          lastModified: new Date(),
          type: blob.type
        });

        this.Attachfiles.push(file);
        this.$nextTick(() => {
          this.insertFile();
        });
      });
      /** //ì‚¬ì§„ì²© í˜¸ì¶œ & íŒŒì¼ê°ì²´ ë³€í™˜ **/
      // this.$refs.photo.click();
    },
    onFileChange: function onFileChange(e) {
      // TODO : ì²¨ë¶€ íŒŒì¼ ê°œìˆ˜ ì œí•œ
      const files = e.target.files || e.dataTransfer.files;
      if (!files.length) {
        return;
      }

      const allowedTypes = [
        'image/jpg',
        'image/jpeg',
        'image/png',
        'image/gif'
      ]; // í—ˆìš©í•  ì´ë¯¸ì§€ íŒŒì¼ í™•ì¥ì ëª©ë¡
      const file = files[0];
      if (!allowedTypes.includes(file.type)) {
        // ì„ íƒí•œ íŒŒì¼ì´ í—ˆìš©ëœ ì´ë¯¸ì§€ íŒŒì¼ í™•ì¥ì ëª©ë¡ì— í¬í•¨ë˜ì§€ ì•ŠëŠ” ê²½ìš°
        this.warningAlert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•´ìš”'); // ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ ë©”ì‹œì§€ ì¶œë ¥
        return;
      }
      this.Attachfiles.push(files[0]);

      this.$nextTick(() => {
        this.insertFile(e);
      });
    },
    //ì‚¬ì§„ ì €ì¥
    insertFile() {
      this.showLoading();
      //ì´ë¯¸ì§€ í™•ì¥ì ìš©ëŸ‰ ì²´í¬
      setFile({
        url: '/setImage',
        param: {},
        file: this.Attachfiles,
        then: (data) => {
          //ì´ˆê¸°í™”
          this.Attachfiles = [];
          this.imgFileId = data.fileId;
          this.imgCdnNm = data.cdnNm;

          this.loading.dismiss();
          this.$nextTick(() => {
            this.send('image');
          });
        }
      });
    },

    agreeYn(type, item) {
      this.showLoading();
      /** ìˆ˜ë½/ê±°ì ˆ ì´ë²¤íŠ¸
       * paramìœ¼ë¡œ ì°¸ì—¬ì‹ ì²­ìID, ì˜¤í”ˆì±—ID, íƒ€ì… **/

      getData({
        url: '/updateOpenChatAttendYn',
        param: {
          openChatKey: item.openChatKey,
          userKey: item.userKey,
          type: type,
          fileId: 0
        },
        then: (data) => {
          if (data.successYn === 'Y') {
            if (data.confirmYn === 'Y') {
              this.warningAlert('ìˆ˜ë½ ì²˜ë¦¬ ë˜ì—ˆìŠµë‹ˆë‹¤');
            } else {
              this.warningAlert('ê±°ì ˆ ì²˜ë¦¬ ë˜ì—ˆìŠµë‹ˆë‹¤');
            }
            this.getUserList();
            this.getAttendList();
            this.updateMessageRecept();
          } else {
            this.warningAlert(data.message);
          }
          this.loading.dismiss();
        }
      });
    },
    /** ì´ë¯¸ì§€ í™•ëŒ€, ì´ë™**/
    openZoomedImage(data) {
      if (!this.isZoomed) {
        const imageUrl = 'https://' + data;
        const modal = document.createElement('div');
        const modalImage = document.createElement('img');

        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.zIndex = '1000';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';

        modalImage.src = imageUrl;
        modalImage.style.width = '90%';
        modalImage.style.height = 'auto';
        modalImage.style.objectFit = 'contain';
        modalImage.style.transformOrigin = 'center';
        modalImage.style.pointerEvents = 'auto';

        modal.appendChild(modalImage);
        document.body.appendChild(modal);

        const hammer = new Hammer(modalImage);

        let currentScale = 1;
        let posX = 0;
        let posY = 0;
        let lastPosX = 0;
        let lastPosY = 0;

        hammer.get('pinch').set({ enable: true });
        hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

        hammer.on('pinchin pinchout', (event) => {
          if (event.type === 'pinchin') {
            currentScale -= 0.02;
          } else if (event.type === 'pinchout') {
            currentScale += 0.02;
          }

          currentScale = Math.min(Math.max(currentScale, 0.5), 3);
          modalImage.style.transform = `translate(${posX}px, ${posY}px) scale(${currentScale})`;
        });

        hammer.on('panmove', (event) => {
          posX = lastPosX + event.deltaX;
          posY = lastPosY + event.deltaY;
          modalImage.style.transform = `translate(${posX}px, ${posY}px) scale(${currentScale})`;
        });

        hammer.on('panend', () => {
          lastPosX = posX;
          lastPosY = posY;
        });

        modal.addEventListener('click', () => {
          document.body.removeChild(modal);
        });
        this.isZoomed = true;
      } else {
        this.isZoomed = false;
      }
    },
    /** ì¢…ë¶ì²´í¬ **/

    boostModalClose() {
      clearInterval(this.interval3);
      this.boostModal = false;
    },

    useOpenChatBoost() {
      getData({
        url: '/messageMain/getChatRoomPrivateCheck',
        param: {
          openchatKey: this.openChatKey
        },
        then: (data) => {
          if (data.privateYn == 'N') {
            this.warningAlert(
              'ë¹„í™œì„± ìƒíƒœì¸ ëª¨ì„ì—ëŠ” ëª¨ì„ë¶€ìŠ¤í„°ë¥¼ <br />ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            );
            return;
          } else {
            let meg = 'ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            if (this.coupon.quantity === 0) {
              meg = 'êµ¬ë§¤ í›„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            }

            if (confirm(meg)) {
              getData({
                url: '/useOpenChatBoost',
                param: {
                  couponCd: 'CU008',
                  useType: this.useType, // 'COUPON', 'HEART'
                  itemCd: this.useType === 'HEART' ? 'IT008_01' : '', // useType
                  pointCd: this.useType === 'HEART' ? 'BUY' : '', // useType
                  openChatKey: this.openChatKey
                },
                then: (data) => {
                  if (
                    data.successYn === 'N' ||
                    data.successYn === 'NH' ||
                    data.successYn === 'NE'
                  ) {
                    this.warningAlert(data.message);
                  } else {
                    this.warningAlert(data.message);

                    this.getBuffUsingInfo();
                    this.getUserCouponDataOne();

                    clearInterval(this.interval3);
                    this.interval3 = setInterval(() => {
                      this.getBuffUsingInfo();
                      this.getUserCouponDataOne();
                    }, 10000);
                  }
                }
              });
            }
          }
        }
      });
    },
    /** ë³´ìœ í˜„í™© **/
    getUserCouponDataOne() {
      let couponCd = 'CU008';
      getData({
        url: '/getUserCouponDataOne',
        param: { couponCd: couponCd },
        then: (data) => {
          this.coupon = data;

          if (this.coupon.quantity > 0) {
            this.useType = 'COUPON';
          } else {
            this.useType = 'HEART';
          }
        }
      });
    },
    openUseOpenChatModal() {
      this.getBuffUsingInfo();
      this.getUserCouponDataOne();
      clearInterval(this.interval3);
      this.interval3 = setInterval(() => {
        this.getBuffUsingInfo();
        this.getUserCouponDataOne();
      }, 10000);
      this.boostModal = true;
    },
    getBuffUsingInfo() {
      getData({
        url: '/getBuffUsingInfo',
        param: {
          couponCd: 'CU008',
          openChatKey: this.openChatKey
        },
        then: (data) => {
          this.isBuffYn = data.isBuffYn;
          this.remainingTime = data.remainingTime;
          this.remainingTimeStr = data.remainingTimeStr;
          this.useCnt = data.useCnt;
          this.openchatRank = data.openchatRank;
          this.totalRoom = data.totalRoom;

          this.$nextTick(() => {
            clearInterval(this.interval2);
            this.timeCal();
            this.interval2 = setInterval(() => {
              if (this.isBuffYn === 'Y') {
                this.timeCal();
              }
            }, 1000);
          });
        }
      });
    },

    /** ë¬´í•œìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ **/
    ionInfinite(event) {
      let self = this;

      if (self.selectType == 'first') {
        self.isEndScroll = true;
        event.target.complete();
        return;
      }

      // ìŠ¤í¬ë¡¤ ë¡œë”© ì…‹íƒ€ì„ì•„ì›ƒ
      setTimeout(function () {
        getData({
          url: '/messageMain/getMessageList',
          param: {
            chatroomId: self.chatroomId,
            type: self.selectType,
            nextNo: self.nextNo
          },
          then: (data) => {
            self.$nextTick(() => {
              // for (let idx in data) {
              //   self.$store.state.messageList.unshift(data[idx]);
              // }
              if (self.selectType != 'first') {
                self.$store.state.messageList.unshift(...data);
              } else {
                self.$store.state.messageList = data;
              }
              self.selectType = 'second';
              if (data.length > 0) {
                self.nextNo = data[0]['messageId'];
              }
              self.isEndScroll = true;
              event.target.complete();

              self.replaceURL();
            });

            if (self.interval4 == null) {
              self.interval4 = setInterval(async () => {
                const elem = self.$refs.msgContainer.$el;
                const scrollElement = await elem.getScrollElement();
                let maxHeight = scrollElement.scrollHeight;
                let currentHeight = scrollElement.scrollTop + 736;
                let heightPx = maxHeight - currentHeight;

                self.$store.state.currentMsgHeightCalc = heightPx;
                self.currentMsgHeightCalc = heightPx;
              }, 2000);
            }
          }
        });
      }, 1000);
    },
    timeCal() {
      let hour, min, sec;

      hour = parseInt(this.remainingTime / 3600);
      min = parseInt((this.remainingTime % 3600) / 60);
      sec = this.remainingTime % 60;

      if (hour.toString().length === 1) hour = '0' + hour;
      if (min.toString().length === 1) min = '0' + min;
      if (sec.toString().length === 1) sec = '0' + sec;

      if (this.remainingTime > 0) {
        this.remainingTime = this.remainingTime - 1;
      } else {
        this.remainingTime = 0;
        clearInterval(this.interval2);
        this.isBuffYn = 'N';
      }
      this.calTimeStr = hour + ':' + min + ':' + sec;
    },
    goRouter(type, item) {
      if (type === 'profile') {
        dailyCardInfoMapFn({ userKey: item.userKey, type: 'messageTalk' });
        this.$router.push('/dailyCardInfo');
      } else if (type === 'police') {
        policeMapFn({
          type: 'message',
          targetKey: item.userKey,
          targetId: item.chatroomId
        });
        this.$router.push('/police');
      } else if (type === 'kick') {
        if (item.subLeaderYn === 'Y') {
          this.warningAlert(
            'ë¶€ë°©ì¥ì€ ê°•í‡´í• ìˆ˜ì—†ìŠµë‹ˆë‹¤. ë¶€ë°©ì¥ì—ì„œ í•´ì œì‹œí‚¨í›„ ê°•í‡´í• ìˆ˜ìˆìŠµë‹ˆë‹¤.'
          );
          return;
        }
        this.targetUserKey = item.userKey;
        this.targetUserType = 'kick';
        this.modalMessage = true;
      } else if (type === 'back') {
        // if (messageTalkMap.type === "police") {
        this.$router.push('/message');
        // } else {
        //   this.$router.go(-1);
        // }
      } else if (type === 'map') {
        messageTalkMapFn({ chatroomId: item, title: this.title });
        this.$router.push('/messageMap');
      } else if (type == 'partnersMap') {
        this.$router.push('/partnersMap');
      } else if (type === 'change') {
        // ë°©ì¥ìœ„ì„
        //console.log("ë°©ì¥ìœ„ì„");
        // return;
        this.confirmBtn(item, 'master');
      } else if (type === 'subChange') {
        this.confirmBtn(item, 'subMaster');
      } else if (type === 'subRemoval') {
        this.confirmBtn(item, 'subRemoval');
      }
    },
    setBlock(item) {
      this.presentAlertConfirm(item);
      // //ì´ë¯¸ ì°¨ë‹¨ë˜ì–´ ìˆëŠ”ì§€í™•ì¸
      // let localStorageNoticeList = JSON.parse(
      //   localStorage.getItem(this.openChatKey)
      // );
      //
      // let isExist = false;
      // for(let idx in localStorageNoticeList){
      //   if(localStorageNoticeList[idx]['userId'] == item.userId){
      //     isExist = true;
      //   }
      // }
      //
      // if(isExist){
      //   //ì°¨ë‹¨í•´ì œ
      //   this.blockCancelConfirmBtn(item);
      // } else {
      //   //ì°¨ë‹¨
      //   this.blockConfirmBtn(item);
      // }
    },
    async blockCancelConfirmBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: 'ì´ë¯¸ ì°¨ë‹¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì°¨ë‹¨ì„ í•´ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
        buttons: [
          {
            text: 'ì·¨ì†Œ',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'í•´ì œ',
            cssClass: 'alert-button-block',
            handler: () => {
              //í•´ë‹¹ì‚¬ìš©ì ì„¸ì…˜ì— ì¶”ê°€í•˜ì—¬ ë©”ì‹œì§€ ê±¸ëŸ¬ëƒ„
              let localStorageBlockList = JSON.parse(
                localStorage.getItem(this.openChatKey)
              );

              console.log(localStorageBlockList);

              for (let i in localStorageBlockList) {
                if (localStorageBlockList[i]['userId'] == item.userId) {
                  localStorageBlockList.splice(i, 1);
                }
              }

              //ì²´í¬ëœ
              if (
                localStorageBlockList == null &&
                typeof localStorageBlockList !== 'array'
              ) {
                localStorageBlockList = [];
              }

              //ìµœì¢… ê²°ê³¼ë¬¼ ì €ì¥
              localStorage.setItem(
                this.openChatKey,
                JSON.stringify(localStorageBlockList)
              );
            }
          }
        ]
      });
      return alert.present();
    },
    async blockConfirmBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message:
          'ì´ ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë¥¼ ì±„íŒ…ì—ì„œ ë” ì´ìƒ ë³´ì§€ ì•ŠìŠµë‹ˆë‹¤. ê³„ì† í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
        buttons: [
          {
            text: 'ì·¨ì†Œ',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'ì°¨ë‹¨',
            cssClass: 'alert-button-block',
            handler: () => {
              //í•´ë‹¹ì‚¬ìš©ì ì„¸ì…˜ì— ì¶”ê°€í•˜ì—¬ ë©”ì‹œì§€ ê±¸ëŸ¬ëƒ„
              let localStorageBlockList = JSON.parse(
                localStorage.getItem(this.openChatKey)
              );

              //ì²´í¬ëœ
              if (
                localStorageBlockList == null &&
                typeof localStorageBlockList !== 'array'
              ) {
                localStorageBlockList = [];
              }
              localStorageBlockList.push({ userId: item.userId });

              //ìµœì¢… ê²°ê³¼ë¬¼ ì €ì¥
              localStorage.setItem(
                this.openChatKey,
                JSON.stringify(localStorageBlockList)
              );

              this.blockFinishBtn();
            }
          }
        ]
      });
      return alert.present();
    },

    async blockFinishBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: 'ì‚¬ìš©ìê°€ ì°¨ë‹¨ë˜ì–´ ë©”ì‹œì§€ë¥¼ ë°›ì§€ ì•Šê²Œë©ë‹ˆë‹¤.',
        buttons: [
          {
            text: 'í™•ì¸',
            role: 'cancel',
            handler: () => {}
          }
        ]
      });
      return alert.present();
    },
    async confirmBtn(item, type) {
      let message, url, btnText;
      if (type === 'master') {
        message = 'ì •ë§ ë°©ì¥ì„ ìœ„ì„ í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
        url = '/messageMain/setRoomMasterChange';
        btnText = 'ìœ„ì„';
      } else if (type === 'subMaster') {
        message = 'ë¶€ë°©ì¥ìœ¼ë¡œ ìœ„ì„ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
        url = '/messageMain/setSubRoomMasterChange';
        btnText = 'ìœ„ì„';
      } else if (type === 'subRemoval') {
        message = 'ë¶€ë°©ì¥ì„ í•´ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
        url = '/messageMain/setSubRoomMasterRemoval';
        btnText = 'í•´ì œ';
      }
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: message,
        buttons: [
          {
            text: 'ì·¨ì†Œ',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: btnText,
            handler: () => {
              getData({
                url: url,
                param: {
                  chatroomId: item.chatroomId,
                  targetUserId: item.userId,
                  subLeaderYn: item.subLeaderYn
                },
                then: (data) => {
                  this.warningAlert(data.message);

                  this.getUserList();
                }
              });
            }
          }
        ]
      });
      return alert.present();
    },
    /** ë¡œë”©ì°½ **/
    async showLoading() {
      this.loading = await this.loadingController.create({
        message: 'Loading...',
        duration: 0
      });

      await this.loading.present();
    },
    async warningAlert(message) {
      const alert = await this.alertController.create({
        header: '',
        subHeader: '',
        message: message,
        buttons: ['OK']
      });
      return alert.present();
    },
    async presentAlertConfirm(item) {
      const alert = await this.alertController.create({
        // cssClass: 'my-custom-class',
        header: '( ' + item.nick + ' ) ë‹˜ì„ ì°¨ë‹¨í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
        message:
          'ì´ ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë¥¼ ì±„íŒ…ì—ì„œ ë” ì´ìƒ ë³´ì§€ ì•ŠìŠµë‹ˆë‹¤. ê³„ì† í•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
        buttons: [
          {
            text: 'ì·¨ì†Œ',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'ì°¨ë‹¨',
            handler: () => {
              /** ì°¨ë‹¨í•˜ê¸° **/
              getData({
                url: '/blockByUserInfo',
                param: { targetUserKey: item.userKey },
                then: (data) => {
                  this.warningAlert(data.message);
                  // ê¸°ì¡´ ë©”ì„¸ì§€ ì¤‘ ì°¨ë‹¨ì‚¬ìš©ìì˜ ë©”ì„¸ì§€ spliceì²˜ë¦¬
                  for (
                    let i = 0;
                    this.$store.state.messageList.length > i;
                    i++
                  ) {
                    if (
                      this.$store.state.messageList[i].regUserKey ==
                      item.userKey
                    ) {
                      this.$store.state.messageList.splice(i + 1, 1);
                    }
                  }
                }
              });
            }
          }
        ]
      });
      return alert.present();
    }
  }
};
</script>

<style lang="scss" scoped>
* {
  user-select: text !important;
  -webkit-user-select: text !important;
}

.important-height {
  height: 2000px;
}

.message-talk-info {
  ion-item {
    --padding-start: 0;
    --inner-padding-end: 0;

    ion-label {
      margin-right: 10px;
    }

    ion-toggle {
      padding-left: 0;
    }
  }
}

.custom-fixed {
  position: fixed;
  display: flex;
  align-items: center;
  top: 65px;
  right: 15px;
  z-index: 1000;
  padding: 3px 15px 3px 3px;
  background: rgba(0, 0, 0, 0.9);
  border-radius: 25px;
}

.alert-button-block {
  color: red !important;
}
</style>
