<template>
  <!-- Ïö∞Ï∏° Î©îÎâ¥ -->
  <!--<ion-router-outlet id="main-content"></ion-router-outlet>-->

  <ion-page>
    <ion-menu side="end" content-id="main-content">
      <ion-header class="ion-padding pb-0" style="margin-top: 30px">
        <ion-list lines="full" class="message-talk-info">
          <ion-item-group>
            <ion-item
              v-if="
                this.messageType == 'message' && this.chatroomType == 'openchat'
              "
            >
              <ion-label>
                <ion-text
                  class="text-pink text-bold text-sm"
                  @click="openUseOpenChatModal"
                  >ÌòÑÏû¨ {{ openchatRank }}ÏúÑ Î™®ÏûÑ üî•
                </ion-text>
                <h3>
                  <ion-text color="light" class="text-bold text-xl"
                    >{{ title }}
                  </ion-text>
                </h3>
                <ion-text
                  color="light"
                  class="text-sm"
                  v-if="this.chatroomType == 'openchat'"
                >
                  <ion-label>{{ talkUserCnt }} / 300Î™Ö</ion-label>
                </ion-text>
              </ion-label>
              <!--              <ion-icon-->
              <!--                slot="end"-->
              <!--                color="light"-->
              <!--                :icon="notificationShakeIcon"-->
              <!--              />-->
              <ion-icon
                slot="end"
                color="light"
                :icon="alarmCheck ? notifications : notificationsOff"
                @click="alarmCheckBtn"
              />
            </ion-item>
            <ion-item v-if="chatroomType != 'anonymous'">
              <ion-row
                class="ion-align-items-center ion-justify-content-between gap-sm w-full flex-nowrap"
              >
                <ion-buttons>
                  <ion-button
                    fill="outline"
                    shape="round"
                    color="primary"
                    class="mt-2 mb-2"
                    @click="goRouter('map', this.chatroomId)"
                  >
                    <ion-icon
                      slot="start"
                      color="light"
                      :icon="mapOutline"
                      size="small"
                    />
                    <ion-text color="light"> ÏßÄÎèÑÏóêÏÑú Î≥¥Í∏∞</ion-text>
                  </ion-button>
                </ion-buttons>
                <div>
                  <ion-item
                    lines="none"
                    v-for="item in this.locationList"
                    v-show="this.SS_USER_KEY === item.userKey"
                    :key="item.userKey"
                    class="ion-align-items-center"
                  >
                    <ion-label>
                      <ion-text color="light" class="text-xs text-bold"
                        >ÎÇ¥ ÏúÑÏπòÍ≥µÏú†
                      </ion-text>
                    </ion-label>
                    <ion-toggle
                      slot="end"
                      :checked="this.toggleLocation"
                      class="v-middle"
                      mode="ios"
                      @click="setLocationYn"
                    ></ion-toggle>
                  </ion-item>
                </div>
              </ion-row>
            </ion-item>
          </ion-item-group>
        </ion-list>
      </ion-header>
      <ion-content class="ion-padding">
        <div class="row-box">
          <ion-list>
            <MessageTalkAttendList>
              <template #title>
                <ion-text>Ï∞∏Ïó¨Ïûê</ion-text>
              </template>
              <template #content>
                <ion-list
                  v-for="data in userRoomList"
                  :key="data.userId"
                  class="pt-0 pb-0"
                >
                  <MessageTalkAttendItem
                    :item="data"
                    :messageType="chatroomType !== 'openchat'"
                    :myCheck="this.SS_USER_KEY === data.userKey"
                    :id="'currentPopoverTrigger' + data.userId"
                  >
                  </MessageTalkAttendItem>
                  <ion-popover
                    :trigger="'currentPopoverTrigger' + data.userId"
                    :dismiss-on-select="true"
                    mode="ios"
                    v-if="
                      chatroomType != 'anonymous' ||
                      this.SS_USER_KEY !== data.userKey
                    "
                  >
                    <ion-content>
                      <ion-list lines="full">
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('profile', data)"
                          v-if="chatroomType != 'anonymous'"
                          >ÌîÑÎ°úÌïÑÎ≥¥Í∏∞
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('kick', data)"
                          v-show="
                            leaderYn == 'Y' &&
                            chatroomType == 'openchat' &&
                            ((this.SS_USER_KEY === data.leaderUserKey &&
                              this.SS_USER_KEY !== data.userKey &&
                              data.subLeaderYn === 'N') ||
                              (data.subLeaderYn === 'N' &&
                                data.leaderNum === 1))
                          "
                          >Í∞ïÌá¥ÌïòÍ∏∞
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('change', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey
                          "
                          >Î∞©Ïû•ÏúÑÏûÑ
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('subChange', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey &&
                            data.subLeaderYn === 'N'
                          "
                          >Î∂ÄÎ∞©Ïû•ÏúÑÏûÑ
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('subRemoval', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey &&
                            data.subLeaderYn === 'Y'
                          "
                          >Î∂ÄÎ∞©Ïû•Ìï¥Ï†ú
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('police', data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          >Ïã†Í≥†ÌïòÍ∏∞
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="setBlock(data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          v-if="chatroomType == 'openchat'"
                          >Ï∞®Îã®ÌïòÍ∏∞
                        </ion-item>
                      </ion-list>
                    </ion-content>
                  </ion-popover>
                </ion-list>
              </template>
            </MessageTalkAttendList>
          </ion-list>
        </div>
        <div class="row-box">
          <ion-list v-if="leaderYn === 'Y' && chatroomType != 'single'">
            <MessageTalkAttendList>
              <template #title>
                <ion-text>Ï∞∏Ïó¨ Ïã†Ï≤≠Ïûê</ion-text>
                <ion-text class="text-sub01"
                  >{{ attendList.length }}Î™Ö
                </ion-text>
              </template>
              <template #actions>
                <!--                <ion-text class="text-link text-sm sub-text01 text-bold"-->
                <!--                >ÏùºÍ¥ÑÏàòÎùΩ-->
                <!--                </ion-text>-->
              </template>
              <template #content>
                <ion-list
                  v-for="data in attendList"
                  :key="data.userId"
                  class="pt-0 pb-0"
                >
                  <MessageTalkAttendItem
                    :item="data"
                    :id="'currentPopoverTrigger' + data.userId"
                  >
                    <template #actions>
                      <custom-button
                        fill="outline"
                        color="success"
                        size="small"
                        shape="round"
                        @click.stop="agreeYn('Y', data)"
                        >ÏàòÎùΩ
                      </custom-button>
                      <custom-button
                        fill="outline"
                        color="danger"
                        size="small"
                        shape="round"
                        @click.stop="agreeYn('N', data)"
                        >Í±∞Ï†à
                      </custom-button>
                    </template>
                  </MessageTalkAttendItem>
                  <ion-popover
                    :trigger="'currentPopoverTrigger' + data.userId"
                    :dismiss-on-select="true"
                    mode="ios"
                  >
                    <ion-content>
                      <ion-list lines="full">
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('profile', data)"
                          >ÌîÑÎ°úÌïÑÎ≥¥Í∏∞
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('kick', data)"
                          v-show="
                            this.SS_USER_KEY === data.leaderUserKey &&
                            this.SS_USER_KEY !== data.userKey
                          "
                          >Í∞ïÌá¥ÌïòÍ∏∞
                        </ion-item>
                        <ion-item
                          :button="true"
                          :detail="false"
                          @click="goRouter('police', data)"
                          v-show="this.SS_USER_KEY !== data.userKey"
                          >Ïã†Í≥†ÌïòÍ∏∞
                        </ion-item>
                      </ion-list>
                    </ion-content>
                  </ion-popover>
                </ion-list>
              </template>
            </MessageTalkAttendList>
          </ion-list>
        </div>
      </ion-content>

      <ion-footer>
        <!-- ÏóÖÏÜå ÌôçÎ≥¥ Î∞∞ÎÑà -->
        <MessageTalkAddBanner @click="goRouter('partnersMap')" />
        <p class="text-right">
          <ion-text class="text-link text-sm" color="light" @Click="chatRoomOut"
            >Ï±ÑÌåÖ ÎÇòÍ∞ÄÍ∏∞
          </ion-text>
        </p>
      </ion-footer>
    </ion-menu>

    <ion-page id="main-content">
      <ion-header>
        <ion-toolbar>
          <ion-buttons slot="start">
            <BackButton @event="goRouter('back')" :custom="true" />
          </ion-buttons>
          <ion-title>{{ title }}</ion-title>
          <ion-buttons slot="end">
            <ion-menu-button @click="menuBtn">
              <ion-icon :icon="menuIcon" color="light" />
            </ion-menu-button>
          </ion-buttons>
        </ion-toolbar>
      </ion-header>
      <ion-content ref="msgContainer" class="ion-padding important-height">
        <div
          v-if="
            this.messageType == 'message' && this.chatroomType == 'openchat'
          "
          class="custom-fixed"
          @click="openUseOpenChatModal"
        >
          <ion-img
            :src="'https://cmdg.speedycdn.net/202308/20230808143353_5905a0f6-1461-4d41-ac99-6b4c8c41dd0d.png'"
            style="width: 35px; height: 35px"
          />
          <ion-text color="light" class="text-bold text-lg">
            &nbsp;TOP {{ openchatRank }}
          </ion-text>
        </div>
        <ion-infinite-scroll
          threshold="100px"
          @ionInfinite="ionInfinite"
          position="top"
        >
          <ion-infinite-scroll-content
            loadingText="Please wait..."
            loadingSpinner="bubbles"
          ></ion-infinite-scroll-content>
        </ion-infinite-scroll>

        <ion-label ref="msgArea">
          <div v-for="item in messageTalkList" v-bind:key="item.messageId">
            <!--ÏÉÅÎåÄÎ∞©-->
            <template
              v-if="
                this.SS_USER_KEY !== item.regUserKey && item.messageType !== 'Y'
              "
            >
              <!--@onImgDidLoad="scrollToBottom(item)"-->
              <!--@ionScroll="handleScroll($event)"-->
              <MessageTalkItem
                :item="item"
                :chatroomType="chatroomType"
                @zoomImg="openZoomedImage(item.cdnNmImage)"
              />
            </template>
            <!--ÎÇò-->
            <template
              v-if="
                this.SS_USER_KEY === item.regUserKey && item.messageType !== 'Y'
              "
            >
              <!--@onImgDidLoad="scrollToBottom(item)"-->
              <MessageTalkItem
                :type="true"
                :item="item"
                :chatroomType="chatroomType"
                @zoomImg="openZoomedImage(item.cdnNmImage)"
              />
            </template>

            <MessageTalkLabel
              :message="item.message"
              v-if="item.messageType === 'Y'"
            />
          </div>
        </ion-label>
      </ion-content>
      <!-- TODO : Ïª§ÎÆ§ÎãàÌã∞ ÎåìÍ∏Ä ÌèºÍ≥º Íµ¨Ï°∞Í∞Ä Îã¨ÎùºÏÑú Í∞úÎ∞ú Î°úÏßÅ ÌÜµÏùº ÌïÑÏöî -->
      <ion-footer @keyup.enter="checkContent" class="no-padding">
        <!--@input="limitComment($event)"-->
        <MessageTalkSendForm
          v-model:value="content"
          :newimgFileId="imgCdnNm"
          :newimgViewFileId="imgCdnNm"
          :emoticonList="emoticonList"
          @handleAddPhoto="addPhoto()"
          @sendComment="send('chat')"
          @emoticonClick="emoticonClick"
          @handleEmoji="handleEmoji"
        />
        <input
          type="file"
          @change="onFileChange"
          ref="photo"
          class="is-blind"
        />
      </ion-footer>
    </ion-page>
    <!-- ÌóàÎãàÎ∂ÄÏä§Ìä∏ Î™®Îã¨Ï∞Ω ÏãúÏûë -->

    <!-- Í∞ïÌá¥ Î™®Îã¨  -->
    <UserKickModal
      :is-open="modalMessage"
      @ionModalDidDismiss="modalMessage = false"
      @ok="modalBtn('save')"
      @cancel="modalBtn('cancel')"
    />

    <!-- Î™®ÏûÑÎ∂ÄÏä§Ìä∏ Î™®Îã¨Ï∞Ω ÏãúÏûë -->
    <CustomBoostModal
      :is-open="boostModal"
      :isBuffYn="isBuffYn"
      :coupon="coupon"
      :openchatRank="openchatRank"
      :totalRoom="totalRoom"
      :useCnt="useCnt"
      :calTimeStr="calTimeStr"
      @ionModalDidDismiss="boostModalClose"
      @close="boostModalClose"
      @event="useOpenChatBoost"
    />
    <AlertMessageModal
      :is-open="messageTalkModal"
      :title="'Ï±ÑÌåÖÎ∞© ÎÇòÍ∞ÄÍ∏∞'"
      :message="
        chatRoomLeaderYn == 'Y' && leaderCanOutYn == 'N'
          ? 'Î∞©Ïû•ÏùÄ ÌòºÏûê ÎÇ®ÏùÄ Í≤ΩÏö∞ÏóêÎßå ÎÇòÍ∞à Ïàò ÏûàÏäµÎãàÎã§.'
          : 'ÎÇòÍ∞ÄÍ∏∞Î•º ÌïòÎ©¥ ÎåÄÌôîÎÇ¥Ïö©Ïù¥ Î™®Îëê ÏÇ≠Ï†úÎêòÍ≥† Ï±ÑÌåÖÎ™©Î°ùÏóêÏÑúÎèÑ ÏÇ≠Ï†úÎê©ÎãàÎã§.'
      "
      :subMessage="''"
      :btnName="'ÎÇòÍ∞ÄÍ∏∞'"
      :height="210"
      :disabledCheck="chatRoomLeaderYn == 'Y' && leaderCanOutYn == 'N'"
      @ionModalDidDismiss="messageTalkModal = false"
      @handleClickBtn="roomExit"
    />
  </ion-page>
</template>

<script>
import { flameOutline, mapOutline } from 'ionicons/icons';
import {
  IonMenu,
  IonToggle,
  IonMenuButton,
  IonInfiniteScroll,
  IonInfiniteScrollContent,
  loadingController,
  alertController
} from '@ionic/vue';
import {
  getData,
  SS_USER_SEQ,
  API_BASE_URL,
  SS_USER_KEY,
  setFile,
  dailyCardInfoMapFn,
  messageTalkMapFn,
  messageTalkMap,
  policeMapFn,
  currentMsgHeightCalc,
  currentMsgHeightCalcFn,
  openChatViewMap,
  openChatMeetMap,
  openChatMeetMapFn,
  openChatViewMapFn
} from '@/assets/js/common';

import SockJS from 'sockjs-client';
import Stomp from 'webstomp-client';
import Hammer from 'hammerjs';

import MessageTalkItem from '@/components/MessageTalk/MessageTalkItem.vue';
import MessageTalkLabel from '@/components/MessageTalk/MessageTalkLabel.vue';
import MessageTalkSendForm from '@/components/MessageTalk/MessageSendForm.vue';
import MessageTalkAttendList from '@/components/MessageTalk/MessageTalkAttendList.vue';
import MessageTalkAttendItem from '@/components/MessageTalk/MessageTalkAttendItem.vue';
import MessageTalkAddBanner from '@/components/MessageTalk/MessageTalkAddBanner.vue';
import UserKickModal from '@/components/Modal/UserKickModal.vue';
import CustomBoostModal from '@/components/Custom/CustomBoostModal.vue';

import IconMenu from '@/assets/img/icon/icon_menu.svg';
import IconNotificationShake from '@/assets/img/icon/icon_notification_shake.svg';
import IconNotifications from '@/assets/img/icon/icon_notifications.svg';
import IconNotificationsOff from '@/assets/img/icon/icon_notifications_off.svg';

//import { Keyboard } from '@capacitor/keyboard';

import {
  CapacitorSQLite,
  SQLiteConnection,
  SQLiteDBConnection
} from '@capacitor-community/sqlite';
import AlertMessageModal from '@/components/Modal/AlertMessageModal.vue';
import { Camera, CameraResultType, CameraSource } from '@capacitor/camera';

import { Capacitor } from '@capacitor/core';
import { MarkerClustering } from '@/assets/js/MarkerClustering';

export default {
  name: 'MessageTalk',
  inject: ['loadingController', 'alertController'],
  components: {
    AlertMessageModal,
    IonInfiniteScroll,
    IonInfiniteScrollContent,
    MessageTalkItem,
    MessageTalkLabel,
    MessageTalkSendForm,
    MessageTalkAttendList,
    MessageTalkAttendItem,
    MessageTalkAddBanner,
    IonMenu,
    IonToggle,
    IonMenuButton,
    UserKickModal,
    CustomBoostModal
  },
  computed: {
    messageTalkList() {
      //storex Í∞êÏãú
      return this.$store.state.messageList;
    }
  },
  watch: {
    messageTalkList: {
      deep: true,
      handler() {
        //computed messageTalkListÍ∞Ä Î≥ÄÌòïÎê†Îïå Ïã§ÌñâÎêòÎäî Ìï®Ïàò
        if (this.currentMsgHeightCalc <= 350) {
          this.scrollToBottom();
        }
      }
    }
  },
  data() {
    return {
      menuIcon: IconMenu,
      notificationShakeIcon: IconNotificationShake,
      notifications: IconNotifications,
      notificationsOff: IconNotificationsOff,
      mapOutline,
      flameOutline,
      API_BASE_URL,
      SS_USER_KEY,
      chatroomId: '',
      messageType: '',
      chatroomType: '',
      loginSeq: SS_USER_SEQ,
      userSeq: '',
      userPhoto: null,
      userNick: '',
      lastSearchTime: '',
      chatBeforeList: [],
      chatList: [],
      content: '',
      container: this.$refs.msgContent,
      stompClient: '',
      connected: false,
      interval: null,
      isFirst: true,
      Attachfiles: [],
      imgFileId: '',
      imgCdnNm: '',
      loading: null,
      isZoomed: false,
      selectType: 'first',
      nextNo: 0,
      userRoomList: [],
      attendList: [],
      showUserList: false,
      showProfileOptions: false,
      currentNick: '',
      title: '',
      talkUserCnt: 0,
      leaderYn: '',

      interval2: null,
      interval3: null,
      interval4: null,
      boostModal: false,
      openchatRank: 0,
      openChatKey: '',
      totalRoom: 0,
      isBuffYn: 'N',
      useCnt: 0,
      calTimeStr: '',
      coupon: {},
      useType: 'HEART',

      modalMessage: false,
      locationList: '',
      currentMsgHeightCalc: 0,
      targetUserKey: '',
      targetUserType: '',
      toggleLocation: false,
      alarmCheck: true,
      emoticonList: [],
      emojiCheck: false,

      isEndScroll: false,
      messageTalkModal: false,
      chatRoomLeaderYn: 'N',
      leaderCanOutYn: 'N',
      isChatBlock: false
    };
  },
  ionViewWillEnter() {
    this.selectType = 'first';
    this.nextNo = 0;
    this.isEndScroll = false;
    this.chatRoomLeaderYn = 'N';
    this.leaderCanOutYn = 'N';
    // ÏßÑÏûÖÌï† Îïå Ìò∏Ï∂ú
    this.chatroomId = messageTalkMap.chatroomId;
    this.messageType = messageTalkMap.type;
    // this.chatroomType = messageTalkMap.chatroomType;
    if (this.$store.state.currentChatroomId != messageTalkMap.chatroomId) {
      this.$store.state.currentChatroomId = messageTalkMap.chatroomId;
      this.$store.state.messageList = [];
    }
    //ÏÜåÏºìÏó∞Í≤∞
    /*this.$nextTick(() => {
      this.connect();
      this.isFirst = false;
    });*/

    //Ï†ëÏÜçÏÉÅÌÉúÎ•º Í∞êÏãúÌï¥ÏÑú Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßàÍ≤ΩÏö∞ Ïû¨Ï†ëÏÜçÌïúÎã§ (1Ï¥àÎ∞òÎ≥µ)
    /*this.interval = setInterval(() => {
      if (!this.isFirst && !this.connected) {
        this.connect();
      }
    }, 500);*/

    this.getChatRoomType();

    this.chatBlock();
  },
  ionViewDidLeave() {
    // Îñ†ÎÇ† Îïå Ìò∏Ï∂ú
    /*clearInterval(this.interval);*/
    clearInterval(this.interval2);
    clearInterval(this.interval3);
    clearInterval(this.interval4);
    //this.stompClient.disconnect(function () {});
    this.isFirst = true;
  },
  mounted() {},
  methods: {
    /** Î∞©Ïû• or Î∂ÄÎ∞©Ïû• Ï≤¥ÌÅ¨ **/
    getLeaderCheck() {
      getData({
        url: '/getLeaderCheck',
        param: {
          chatroomId: this.chatroomId,
          openChatKey: this.openChatKey
        },
        then: (data) => {
          this.leaderYn = data.leaderYn;
        }
      });
    },

    chatRoomOut() {
      if (this.chatroomType == 'openchat') {
        if (this.chatRoomLeaderYn == 'Y') {
          if (this.userRoomList.length <= 1) {
            this.leaderCanOutYn = 'Y';
          } else {
            this.leaderCanOutYn = 'N';
          }
        }
      } else {
        this.leaderCanOutYn = 'Y';
      }

      this.messageTalkModal = true;
    },

    roomLeaderExit() {
      getData({
        url: '/messageMain/setDropOutLeader',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          // this.$router.push("message");
          this.messageTalkModal = false;
          this.$router.go(-1);
        }
      });
    },
    handleEmoji() {
      this.$refs.msgContainer.$el.scrollToBottom(0);
    },
    getChatRoomType() {
      getData({
        url: '/messageMain/getChatRoomType',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.chatroomType = data.chatroomType;

          this.updateMessageRecept();
          this.getMessageList();

          this.getLocationListCheck();

          this.initSqlite();
          this.getEmoticonList();

          this.getChatroomTitle();
          this.getLocationYn();
        }
      });
    },
    emoticonClick(item) {
      this.content = item.emoticonNm;
      this.imgFileId = item.fileId;

      this.send('emoticon');
    },
    chatBlock() {
      getData({
        url: '/messageMain/chatBlock',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.isChatBlock = data.isBlock == 'Y' ? true : false;
        }
      });
    },
    /** Ïù¥Î™®Ìã∞ÏΩò **/
    getEmoticonList() {
      getData({
        url: '/messageMain/getEmoticonList',
        param: {},
        then: (data) => {
          this.emoticonList = data;
        }
      });
    },
    /** ÏïåÎûå on/off **/
    alarmCheckBtn() {
      getData({
        url: '/messageMain/getChatRoomAlarm',
        param: { alarmCheck: this.alarmCheck, chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.getChatRoomAlarmList();
          }
        }
      });
    },
    /** ÏïåÎûåÏÉÅÌÉú Ï≤¥ÌÅ¨ **/
    getChatRoomAlarmList() {
      getData({
        url: '/messageMain/getChatRoomAlarmList',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.alarmCheck = data.val === 'Y' ? true : false;
        }
      });
    },
    menuBtn() {
      this.getLeaderCheck();
      this.getUserList();
      this.getAttendList();
      this.getChatroomTitle();
      this.getChatRoomAlarmList();
    },

    handleScroll(ev) {
      console.log('scroll' + ev.detail);
    },
    async initSqlite() {
      const sqlite = new SQLiteConnection(CapacitorSQLite);
      if (Capacitor.getPlatform() === 'web') {
        const jeepSqlite = document.createElement('jeep-sqlite');
        document.body.appendChild(jeepSqlite);
        await customElements.whenDefined('jeep-sqlite');
        await sqlite.initWebStore();
      }
      let db;
      const ret = await sqlite.checkConnectionsConsistency();
      const isConn = (await sqlite.isConnection('navy')).result;
      if (ret.result && isConn) {
        db = await sqlite.retrieveConnection('navy');
      } else {
        db = await sqlite.createConnection('navy', false, 'no-encryption', 1);
      }
      await db.open();
      const res3 = await db.query('SELECT * FROM test');
      //console.log(res3.values);

      await sqlite.closeConnection('navy');
    },
    modalBtn(type) {
      if (type === 'save') {
        this.getKickUser();
      } else {
        this.modalMessage = false;
      }
    },

    openProfile(userId, userNick) {
      this.currentNick = userNick;
      this.showProfileOptions = true;
    },
    roomExit() {
      if (this.chatRoomLeader == 'Y' && this.leaderCanOutYn == 'Y') {
        this.roomLeaderExit();
      } else if (this.chatRoomLeader == 'Y' && this.leaderCanOutYn == 'N') {
        // Ìï¥Îãπ Í≤ΩÏö∞Îäî ÏóÜÏñ¥Ïïº Ï†ïÏÉÅ
        this.warningAlert(
          'ÏÜåÎ™®ÏûÑÏóêÏÑú Î∞©Ïû•ÏùÄ ÌòºÏûê ÎÇ®ÏùÄ Í≤ΩÏö∞ÏóêÎßå ÎÇòÍ∞à Ïàò ÏûàÏäµÎãàÎã§.'
        );
      } else {
        this.targetUserKey = this.SS_USER_KEY;
        this.targetUserType = 'self';
        this.getKickUser();
      }
    },
    getKickUser() {
      getData({
        url: '/messageMain/setDropOutUser',
        param: {
          chatroomId: this.chatroomId,
          userKey: this.targetUserKey,
          type: this.targetUserType
        },
        then: (data) => {
          if (data.successYn === 'Y') {
            if (this.targetUserType === 'kick') {
              this.userRoomList = data.roomUserList;

              this.getUserList();
              this.getAttendList();
              this.updateMessageRecept();
              this.modalMessage = false;
            } else if (this.targetUserType === 'self') {
              // this.$router.push("message");
              this.messageTalkModal = false;
              this.$router.go(-1);
            }
          } else {
            this.warningAlert(data.message);
          }
        }
      });
    },
    /*connect() {
      const serverURL = API_BASE_URL + '/commonSocket';
      let socket = new SockJS(serverURL);
      this.stompClient = Stomp.over(socket);
      console.log("ÏÜåÏºì Ïó∞Í≤∞ÏùÑ ÏãúÎèÑÌï©ÎãàÎã§. ÏÑúÎ≤Ñ Ï£ºÏÜå: " + serverURL);
      this.stompClient.connect(
        {},
        (frame) => {
          // ÏÜåÏºì Ïó∞Í≤∞ ÏÑ±Í≥µ
          this.connected = true;
          console.log("ÏÜåÏºì Ïó∞Í≤∞ ÏÑ±Í≥µ", frame);
          // ÏÑúÎ≤ÑÏùò Î©îÏãúÏßÄ Ï†ÑÏÜ° endpointÎ•º Íµ¨ÎèÖÌï©ÎãàÎã§.
          // Ïù¥Îü∞ÌòïÌÉúÎ•º pub sub Íµ¨Ï°∞ÎùºÍ≥† Ìï©ÎãàÎã§.
          this.stompClient.subscribe("/channel/" + this.chatroomId, (res) => {
            // Î∞õÏùÄ Îç∞Ïù¥ÌÑ∞Î•º jsonÏúºÎ°ú ÌååÏã±ÌïòÍ≥† Î¶¨Ïä§Ìä∏Ïóê ÎÑ£Ïñ¥Ï§çÎãàÎã§
            this.messageTalkList.push(JSON.parse(res.body));
            this.scrollToBottom();
          });
          //ÏÜåÏºìÏó∞Í≤∞Ïù¥ ÏôÑÎ£åÎêú Ïù¥ÌõÑ Îç∞Ïù¥ÌÑ∞Î•º Ï°∞ÌöåÌïúÎã§.
          //Î©îÏÑ∏ÏßÄ ÏùΩÏùå Ï≤òÎ¶¨
          this.updateMessageRecept();
          //Î©îÏÑ∏ÏßÄ Ï°∞Ìöå
          this.getMessageList();
        },
        (error) => {
          // ÏÜåÏºì Ïó∞Í≤∞ Ïã§Ìå®
          console.log("ÏÜåÏºì Ïó∞Í≤∞ Ïã§Ìå®", error);
          this.connected = false;
        }
      );
    },*/
    /* Ïä§ÌÅ¨Î°§ Îß® ÏïÑÎûòÎ°ú */
    scrollToBottom(item) {
      if (item !== undefined && item !== null) {
        item.isLoaded = true;
      }

      setTimeout(() => {
        this.$refs.msgContainer.$el.scrollToBottom(0);
      }, 100);
    },
    getMessageList() {
      let self = this;

      this.talkUserCnt = 0;
      if (this.selectType !== 'first' && this.nextNo === '0') {
        alert('ÏãúÏä§ÌÖúÏò§Î•ò Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.');
        return;
      }

      clearInterval(this.interval4);

      getData({
        url: '/messageMain/getMessageList',
        param: {
          chatroomId: this.chatroomId,
          type: this.selectType,
          nextNo: this.nextNo
        },
        then: (data) => {
          this.$store.state.messageList = data;
          if (data.length > 0) {
            this.selectType = 'second';
            this.nextNo = data[0]['messageId'];
          }
          this.$nextTick(() => {
            //this.scrollToBottom();

            self.interval4 = setInterval(async () => {
              const elem = self.$refs.msgContainer.$el;
              const scrollElement = await elem.getScrollElement();
              let maxHeight = scrollElement.scrollHeight;
              let currentHeight = scrollElement.scrollTop + 736;
              let heightPx = maxHeight - currentHeight;

              self.$store.state.currentMsgHeightCalc = heightPx;
              self.currentMsgHeightCalc = heightPx;
            }, 2000);

            self.replaceURL();
          });
        }
      });
    },
    updateMessageRecept() {
      //Î©îÏãúÏßÄ ÏùΩÏùåÏ≤òÎ¶¨
      getData({
        url: '/messageMain/updateMessageRecept',
        param: { chatroomId: this.chatroomId },
        then: () => {}
      });
    },

    /** Ï±óÎ∞© Ïú†Ï†ÄÎ¶¨Ïä§Ìä∏ **/
    getUserList() {
      getData({
        url: '/messageMain/getRoomUserList',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          this.userRoomList = data;
          this.talkUserCnt = data.length;

          this.$nextTick(() => {
            this.getAttendList();
          });
        }
      });
    },
    getLocationListCheck() {
      getData({
        url: '/messageMain/getLocationListCheck',
        param: {
          chatroomId: this.chatroomId
        },
        then: (data) => {
          this.locationList = data;
        }
      });
    },
    getLocationYn() {
      getData({
        url: '/messageMain/getLocationYn',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.toggleLocation = data.locationYn == 'Y' ? true : false;
          }
        }
      });
    },
    setLocationYn() {
      getData({
        url: '/messageMain/setLocationYn',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          if (data.successYn === 'N') {
            this.warningAlert(data.message);
          } else {
            this.toggleLocation = data.updatedValue === 'Y' ? true : false;
          }
          this.getUserList();
        }
      });
    },
    /** Ï±óÎ∞© Ïã†Ï≤≠Ïú†Ï†ÄÎ¶¨Ïä§Ìä∏ **/
    getAttendList() {
      getData({
        url: '/messageMain/getAttendList',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.attendList = data;

          // this.$nextTick(() => {
          //   if (messageTalkMap.type != "message"
          //     || (messageTalkMap.type == "message" && messageTalkMap.chatroomType == "openchat")) {
          //     this.getChatroomTitle();
          //   }
          // });
        }
      });
    },

    getChatroomTitle() {
      getData({
        url: '/messageMain/getChatroomTitle',
        param: { chatroomId: this.chatroomId },
        then: (data) => {
          this.title = data.title ? data.title : 'ÎåÄÌôîÏÉÅÎåÄÍ∞Ä ÏóÜÏäµÎãàÎã§.';
          this.openchatRank = data.openchatRank;
          this.openChatKey = data.openChatKey;
          this.chatRoomLeaderYn = data.leaderYn;
        }
      });
    },

    /* Îπà Î¨∏ÏûêÏó¥Ïù∏ÏßÄ ÏïÑÎãåÏßÄ Î®ºÏ†Ä Ï≤¥ÌÅ¨ÌïòÍ∏∞ */
    checkContent(e) {
      /*if (this.content === null || this.content === '') {
        /!* Îπà Î¨∏ÏûêÏó¥Ïù¥ Îì§Ïñ¥Ïò§Î©¥ alertÏ∞Ω ÎùÑÏö∞Í∏∞. *!/
        return;
      } else {
        /!* ÎπàÎ¨∏ÏûêÏó¥Ïù¥ ÏïÑÎãàÎ©¥ ÎÇ¥Ïö© Î≥¥ÎÇ¥Í∏∞ *!/
        this.send('chat');
      }*/
    },

    /* Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ° */
    send(type) {
      //if (this.stompClient && this.stompClient.connected) {
      //const msg = { name: this.send_message };
      //this.stompClient.send("/app/hello", JSON.stringify(msg), {});
      if (this.isChatBlock) {
        this.warningAlert(
          'ÏÇ≠Ï†úÎêú ÏÜåÎ™®ÏûÑÏûÖÎãàÎã§.<br />ÏÇ≠Ï†úÎêú Í∏ÄÏóêÎäî Îçî Ïù¥ÏÉÅ Ï±ÑÌåÖÏùÑ Ìï† Ïàò ÏóÜÏäµÎãàÎã§.'
        );
        return;
      }

      if (
        type !== 'emoticon' &&
        type !== 'image' &&
        (this.content === null || this.content === '')
      ) {
        this.warningAlert('Î≥¥ÎÇº Î©îÏÑ∏ÏßÄÎ•º ÏûëÏÑ±Ìï¥ Ï£ºÏÑ∏Ïöî');
        return;
      }

      if (type !== 'image' && type !== 'emoticon') {
        this.imgFileId = '';
        this.imgCdnNm = '';
      }
      getData({
        url: '/messageMain/sendMessageSingle',
        param: {
          chatroomId: this.chatroomId,
          message: this.content,
          type: type,
          fileId: this.imgFileId
        },
        then: (res) => {
          if (res.successYn == 'N') {
            this.warningAlert(res.message);
          } else {
            this.imgFileId = '';
            this.imgCdnNm = '';
            this.messageTalkList.push(res);
            this.scrollToBottom();
          }

          this.$nextTick(() => {
            this.replaceURL();
          });
        }
      });
      //}

      //inputÏ∞Ω Î¶¨ÏÖã
      this.content = '';
    },

    replaceURL() {
      //Ï∞®Îã®Îêú ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï†úÍ±∞
      /*let localStorageBlockList = JSON.parse(
        localStorage.getItem(this.openChatKey)
      );*/

      let regexp = /(?:http(s?)?|www)\S+\w/g;
      Array.from(this.messageTalkList).forEach((message, index) => {
        let _match = message.message.match(regexp);
        let match = [...new Set(_match)];
        this.messageTalkList[index]['replaceMessage'] = message.message;
        Array.from(match).forEach((item) => {
          if (!item.includes('http')) {
            this.messageTalkList[index]['replaceMessage'] =
              this.messageTalkList[index]['replaceMessage'].replaceAll(
                item,
                `<a href="http://${item}" target="_blank">${item}</a>`
              );
          } else {
            this.messageTalkList[index]['replaceMessage'] =
              this.messageTalkList[index]['replaceMessage'].replaceAll(
                item,
                `<a href="${item}" target="_blank">${item}</a>`
              );
          }
        });
      });
    },

    addPhoto() {
      /** ÏÇ¨ÏßÑÏ≤© Ìò∏Ï∂ú & ÌååÏùºÍ∞ùÏ≤¥ Î≥ÄÌôò **/
      Camera.getPhoto({
        allowEditing: false, //ÏÇ¨ÏßÑÏàòÏ†ïÏó¨Î∂Ä (ÏïàÎìúÎ°úÏù¥ÎìúÎßå Í∞ÄÎä•, IOSÎäî Ïπ¥Î©îÎùº Ï¥¨ÏòÅÏãúÎßå ÏàòÏ†ï)
        source: CameraSource.Photos, //ÏÇ¨ÏßÑÏ≤®, Ï¥¨ÏòÅ, Îì± ÏÑ§Ï†ï
        resultType: CameraResultType.Uri //ÏÇ¨ÏßÑ result Type
      }).then(async (photo) => {
        let blob = await fetch(photo.webPath).then((r) => r.blob());
        const file = new File([blob], 'fileName.' + photo.format, {
          lastModified: new Date(),
          type: blob.type
        });

        this.Attachfiles.push(file);
        this.$nextTick(() => {
          this.insertFile();
        });
      });
      /** //ÏÇ¨ÏßÑÏ≤© Ìò∏Ï∂ú & ÌååÏùºÍ∞ùÏ≤¥ Î≥ÄÌôò **/
      // this.$refs.photo.click();
    },
    onFileChange: function onFileChange(e) {
      // TODO : Ï≤®Î∂Ä ÌååÏùº Í∞úÏàò Ï†úÌïú
      const files = e.target.files || e.dataTransfer.files;
      if (!files.length) {
        return;
      }

      const allowedTypes = [
        'image/jpg',
        'image/jpeg',
        'image/png',
        'image/gif'
      ]; // ÌóàÏö©Ìï† Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÌôïÏû•Ïûê Î™©Î°ù
      const file = files[0];
      if (!allowedTypes.includes(file.type)) {
        // ÏÑ†ÌÉùÌïú ÌååÏùºÏù¥ ÌóàÏö©Îêú Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÌôïÏû•Ïûê Î™©Î°ùÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÎäî Í≤ΩÏö∞
        this.warningAlert('Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï¥Ïöî'); // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º Î©îÏãúÏßÄ Ï∂úÎ†•
        return;
      }
      this.Attachfiles.push(files[0]);

      this.$nextTick(() => {
        this.insertFile(e);
      });
    },
    //ÏÇ¨ÏßÑ Ï†ÄÏû•
    insertFile() {
      this.showLoading();
      //Ïù¥ÎØ∏ÏßÄ ÌôïÏû•Ïûê Ïö©Îüâ Ï≤¥ÌÅ¨
      setFile({
        url: '/setImage',
        param: {},
        file: this.Attachfiles,
        then: (data) => {
          //Ï¥àÍ∏∞Ìôî
          this.Attachfiles = [];
          this.imgFileId = data.fileId;
          this.imgCdnNm = data.cdnNm;

          this.loading.dismiss();
          this.$nextTick(() => {
            this.send('image');
          });
        }
      });
    },

    agreeYn(type, item) {
      this.showLoading();
      /** ÏàòÎùΩ/Í±∞Ï†à Ïù¥Î≤§Ìä∏
       * paramÏúºÎ°ú Ï∞∏Ïó¨Ïã†Ï≤≠ÏûêID, Ïò§ÌîàÏ±óID, ÌÉÄÏûÖ **/

      getData({
        url: '/updateOpenChatAttendYn',
        param: {
          openChatKey: item.openChatKey,
          userKey: item.userKey,
          type: type,
          fileId: 0
        },
        then: (data) => {
          if (data.successYn === 'Y') {
            if (data.confirmYn === 'Y') {
              this.warningAlert('ÏàòÎùΩ Ï≤òÎ¶¨ ÎêòÏóàÏäµÎãàÎã§');
            } else {
              this.warningAlert('Í±∞Ï†à Ï≤òÎ¶¨ ÎêòÏóàÏäµÎãàÎã§');
            }
            this.getUserList();
            this.getAttendList();
            this.updateMessageRecept();
          } else {
            this.warningAlert(data.message);
          }
          this.loading.dismiss();
        }
      });
    },
    /** Ïù¥ÎØ∏ÏßÄ ÌôïÎåÄ, Ïù¥Îèô**/
    openZoomedImage(data) {
      if (!this.isZoomed) {
        const imageUrl = 'https://' + data;
        const modal = document.createElement('div');
        const modalImage = document.createElement('img');

        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.zIndex = '1000';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';

        modalImage.src = imageUrl;
        modalImage.style.width = '90%';
        modalImage.style.height = 'auto';
        modalImage.style.objectFit = 'contain';
        modalImage.style.transformOrigin = 'center';
        modalImage.style.pointerEvents = 'auto';

        modal.appendChild(modalImage);
        document.body.appendChild(modal);

        const hammer = new Hammer(modalImage);

        let currentScale = 1;
        let posX = 0;
        let posY = 0;
        let lastPosX = 0;
        let lastPosY = 0;

        hammer.get('pinch').set({ enable: true });
        hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

        hammer.on('pinchin pinchout', (event) => {
          if (event.type === 'pinchin') {
            currentScale -= 0.02;
          } else if (event.type === 'pinchout') {
            currentScale += 0.02;
          }

          currentScale = Math.min(Math.max(currentScale, 0.5), 3);
          modalImage.style.transform = `translate(${posX}px, ${posY}px) scale(${currentScale})`;
        });

        hammer.on('panmove', (event) => {
          posX = lastPosX + event.deltaX;
          posY = lastPosY + event.deltaY;
          modalImage.style.transform = `translate(${posX}px, ${posY}px) scale(${currentScale})`;
        });

        hammer.on('panend', () => {
          lastPosX = posX;
          lastPosY = posY;
        });

        modal.addEventListener('click', () => {
          document.body.removeChild(modal);
        });
        this.isZoomed = true;
      } else {
        this.isZoomed = false;
      }
    },
    /** Ï¢ÖÎ∂ÅÏ≤¥ÌÅ¨ **/

    boostModalClose() {
      clearInterval(this.interval3);
      this.boostModal = false;
    },

    useOpenChatBoost() {
      getData({
        url: '/messageMain/getChatRoomPrivateCheck',
        param: {
          openchatKey: this.openChatKey
        },
        then: (data) => {
          if (data.privateYn == 'N') {
            this.warningAlert(
              'ÎπÑÌôúÏÑ± ÏÉÅÌÉúÏù∏ Î™®ÏûÑÏóêÎäî Î™®ÏûÑÎ∂ÄÏä§ÌÑ∞Î•º <br />ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§.'
            );
            return;
          } else {
            let meg = 'ÏÇ¨Ïö©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
            if (this.coupon.quantity === 0) {
              meg = 'Íµ¨Îß§ ÌõÑ ÏÇ¨Ïö©ÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
            }

            if (confirm(meg)) {
              getData({
                url: '/useOpenChatBoost',
                param: {
                  couponCd: 'CU008',
                  useType: this.useType, // 'COUPON', 'HEART'
                  itemCd: this.useType === 'HEART' ? 'IT008_01' : '', // useType
                  pointCd: this.useType === 'HEART' ? 'BUY' : '', // useType
                  openChatKey: this.openChatKey
                },
                then: (data) => {
                  if (
                    data.successYn === 'N' ||
                    data.successYn === 'NH' ||
                    data.successYn === 'NE'
                  ) {
                    this.warningAlert(data.message);
                  } else {
                    this.warningAlert(data.message);

                    this.getBuffUsingInfo();
                    this.getUserCouponDataOne();

                    clearInterval(this.interval3);
                    this.interval3 = setInterval(() => {
                      this.getBuffUsingInfo();
                      this.getUserCouponDataOne();
                    }, 10000);
                  }
                }
              });
            }
          }
        }
      });
    },
    /** Î≥¥Ïú†ÌòÑÌô© **/
    getUserCouponDataOne() {
      let couponCd = 'CU008';
      getData({
        url: '/getUserCouponDataOne',
        param: { couponCd: couponCd },
        then: (data) => {
          this.coupon = data;

          if (this.coupon.quantity > 0) {
            this.useType = 'COUPON';
          } else {
            this.useType = 'HEART';
          }
        }
      });
    },
    openUseOpenChatModal() {
      this.getBuffUsingInfo();
      this.getUserCouponDataOne();
      clearInterval(this.interval3);
      this.interval3 = setInterval(() => {
        this.getBuffUsingInfo();
        this.getUserCouponDataOne();
      }, 10000);
      this.boostModal = true;
    },
    getBuffUsingInfo() {
      getData({
        url: '/getBuffUsingInfo',
        param: {
          couponCd: 'CU008',
          openChatKey: this.openChatKey
        },
        then: (data) => {
          this.isBuffYn = data.isBuffYn;
          this.remainingTime = data.remainingTime;
          this.remainingTimeStr = data.remainingTimeStr;
          this.useCnt = data.useCnt;
          this.openchatRank = data.openchatRank;
          this.totalRoom = data.totalRoom;

          this.$nextTick(() => {
            clearInterval(this.interval2);
            this.timeCal();
            this.interval2 = setInterval(() => {
              if (this.isBuffYn === 'Y') {
                this.timeCal();
              }
            }, 1000);
          });
        }
      });
    },

    /** Î¨¥ÌïúÏä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ **/
    ionInfinite(event) {
      let self = this;

      if (self.selectType == 'first') {
        self.isEndScroll = true;
        event.target.complete();
        return;
      }

      // Ïä§ÌÅ¨Î°§ Î°úÎî© ÏÖãÌÉÄÏûÑÏïÑÏõÉ
      setTimeout(function () {
        getData({
          url: '/messageMain/getMessageList',
          param: {
            chatroomId: self.chatroomId,
            type: self.selectType,
            nextNo: self.nextNo
          },
          then: (data) => {
            self.$nextTick(() => {
              // for (let idx in data) {
              //   self.$store.state.messageList.unshift(data[idx]);
              // }
              if (self.selectType != 'first') {
                self.$store.state.messageList.unshift(...data);
              } else {
                self.$store.state.messageList = data;
              }
              self.selectType = 'second';
              if (data.length > 0) {
                self.nextNo = data[0]['messageId'];
              }
              self.isEndScroll = true;
              event.target.complete();

              self.replaceURL();
            });

            if (self.interval4 == null) {
              self.interval4 = setInterval(async () => {
                const elem = self.$refs.msgContainer.$el;
                const scrollElement = await elem.getScrollElement();
                let maxHeight = scrollElement.scrollHeight;
                let currentHeight = scrollElement.scrollTop + 736;
                let heightPx = maxHeight - currentHeight;

                self.$store.state.currentMsgHeightCalc = heightPx;
                self.currentMsgHeightCalc = heightPx;
              }, 2000);
            }
          }
        });
      }, 1000);
    },
    timeCal() {
      let hour, min, sec;

      hour = parseInt(this.remainingTime / 3600);
      min = parseInt((this.remainingTime % 3600) / 60);
      sec = this.remainingTime % 60;

      if (hour.toString().length === 1) hour = '0' + hour;
      if (min.toString().length === 1) min = '0' + min;
      if (sec.toString().length === 1) sec = '0' + sec;

      if (this.remainingTime > 0) {
        this.remainingTime = this.remainingTime - 1;
      } else {
        this.remainingTime = 0;
        clearInterval(this.interval2);
        this.isBuffYn = 'N';
      }
      this.calTimeStr = hour + ':' + min + ':' + sec;
    },
    goRouter(type, item) {
      if (type === 'profile') {
        dailyCardInfoMapFn({ userKey: item.userKey, type: 'messageTalk' });
        this.$router.push('/dailyCardInfo');
      } else if (type === 'police') {
        policeMapFn({
          type: 'message',
          targetKey: item.userKey,
          targetId: item.chatroomId
        });
        this.$router.push('/police');
      } else if (type === 'kick') {
        if (item.subLeaderYn === 'Y') {
          this.warningAlert(
            'Î∂ÄÎ∞©Ïû•ÏùÄ Í∞ïÌá¥Ìï†ÏàòÏóÜÏäµÎãàÎã§. Î∂ÄÎ∞©Ïû•ÏóêÏÑú Ìï¥Ï†úÏãúÌÇ®ÌõÑ Í∞ïÌá¥Ìï†ÏàòÏûàÏäµÎãàÎã§.'
          );
          return;
        }
        this.targetUserKey = item.userKey;
        this.targetUserType = 'kick';
        this.modalMessage = true;
      } else if (type === 'back') {
        // if (messageTalkMap.type === "police") {
        this.$router.push('/message');
        // } else {
        //   this.$router.go(-1);
        // }
      } else if (type === 'map') {
        messageTalkMapFn({ chatroomId: item, title: this.title });
        this.$router.push('/messageMap');
      } else if (type == 'partnersMap') {
        this.$router.push('/partnersMap');
      } else if (type === 'change') {
        // Î∞©Ïû•ÏúÑÏûÑ
        //console.log("Î∞©Ïû•ÏúÑÏûÑ");
        // return;
        this.confirmBtn(item, 'master');
      } else if (type === 'subChange') {
        this.confirmBtn(item, 'subMaster');
      } else if (type === 'subRemoval') {
        this.confirmBtn(item, 'subRemoval');
      }
    },
    setBlock(item) {
      this.presentAlertConfirm(item);
      // //Ïù¥ÎØ∏ Ï∞®Îã®ÎêòÏñ¥ ÏûàÎäîÏßÄÌôïÏù∏
      // let localStorageNoticeList = JSON.parse(
      //   localStorage.getItem(this.openChatKey)
      // );
      //
      // let isExist = false;
      // for(let idx in localStorageNoticeList){
      //   if(localStorageNoticeList[idx]['userId'] == item.userId){
      //     isExist = true;
      //   }
      // }
      //
      // if(isExist){
      //   //Ï∞®Îã®Ìï¥Ï†ú
      //   this.blockCancelConfirmBtn(item);
      // } else {
      //   //Ï∞®Îã®
      //   this.blockConfirmBtn(item);
      // }
    },
    async blockCancelConfirmBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: 'Ïù¥ÎØ∏ Ï∞®Îã®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Ï∞®Îã®ÏùÑ Ìï¥Ï†ú ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        buttons: [
          {
            text: 'Ï∑®ÏÜå',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'Ìï¥Ï†ú',
            cssClass: 'alert-button-block',
            handler: () => {
              //Ìï¥ÎãπÏÇ¨Ïö©Ïûê ÏÑ∏ÏÖòÏóê Ï∂îÍ∞ÄÌïòÏó¨ Î©îÏãúÏßÄ Í±∏Îü¨ÎÉÑ
              let localStorageBlockList = JSON.parse(
                localStorage.getItem(this.openChatKey)
              );

              console.log(localStorageBlockList);

              for (let i in localStorageBlockList) {
                if (localStorageBlockList[i]['userId'] == item.userId) {
                  localStorageBlockList.splice(i, 1);
                }
              }

              //Ï≤¥ÌÅ¨Îêú
              if (
                localStorageBlockList == null &&
                typeof localStorageBlockList !== 'array'
              ) {
                localStorageBlockList = [];
              }

              //ÏµúÏ¢Ö Í≤∞Í≥ºÎ¨º Ï†ÄÏû•
              localStorage.setItem(
                this.openChatKey,
                JSON.stringify(localStorageBlockList)
              );
            }
          }
        ]
      });
      return alert.present();
    },
    async blockConfirmBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message:
          'Ïù¥ ÏÇ¨Ïö©ÏûêÏùò Î©îÏãúÏßÄÎ•º Ï±ÑÌåÖÏóêÏÑú Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄ ÏïäÏäµÎãàÎã§. Í≥ÑÏÜç ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        buttons: [
          {
            text: 'Ï∑®ÏÜå',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'Ï∞®Îã®',
            cssClass: 'alert-button-block',
            handler: () => {
              //Ìï¥ÎãπÏÇ¨Ïö©Ïûê ÏÑ∏ÏÖòÏóê Ï∂îÍ∞ÄÌïòÏó¨ Î©îÏãúÏßÄ Í±∏Îü¨ÎÉÑ
              let localStorageBlockList = JSON.parse(
                localStorage.getItem(this.openChatKey)
              );

              //Ï≤¥ÌÅ¨Îêú
              if (
                localStorageBlockList == null &&
                typeof localStorageBlockList !== 'array'
              ) {
                localStorageBlockList = [];
              }
              localStorageBlockList.push({ userId: item.userId });

              //ÏµúÏ¢Ö Í≤∞Í≥ºÎ¨º Ï†ÄÏû•
              localStorage.setItem(
                this.openChatKey,
                JSON.stringify(localStorageBlockList)
              );

              this.blockFinishBtn();
            }
          }
        ]
      });
      return alert.present();
    },

    async blockFinishBtn(item) {
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: 'ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∞®Îã®ÎêòÏñ¥ Î©îÏãúÏßÄÎ•º Î∞õÏßÄ ÏïäÍ≤åÎê©ÎãàÎã§.',
        buttons: [
          {
            text: 'ÌôïÏù∏',
            role: 'cancel',
            handler: () => {}
          }
        ]
      });
      return alert.present();
    },
    async confirmBtn(item, type) {
      let message, url, btnText;
      if (type === 'master') {
        message = 'Ï†ïÎßê Î∞©Ïû•ÏùÑ ÏúÑÏûÑ ÌïòÏãúÍ≤†ÏäµÎãàÍπå? ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.';
        url = '/messageMain/setRoomMasterChange';
        btnText = 'ÏúÑÏûÑ';
      } else if (type === 'subMaster') {
        message = 'Î∂ÄÎ∞©Ïû•ÏúºÎ°ú ÏúÑÏûÑ ÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
        url = '/messageMain/setSubRoomMasterChange';
        btnText = 'ÏúÑÏûÑ';
      } else if (type === 'subRemoval') {
        message = 'Î∂ÄÎ∞©Ïû•ÏùÑ Ìï¥Ï†ú ÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
        url = '/messageMain/setSubRoomMasterRemoval';
        btnText = 'Ìï¥Ï†ú';
      }
      const alert = await alertController.create({
        //cssClass: 'my-custom-class',
        header: '',
        message: message,
        buttons: [
          {
            text: 'Ï∑®ÏÜå',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: btnText,
            handler: () => {
              getData({
                url: url,
                param: {
                  chatroomId: item.chatroomId,
                  targetUserId: item.userId,
                  subLeaderYn: item.subLeaderYn
                },
                then: (data) => {
                  this.warningAlert(data.message);

                  this.getUserList();
                }
              });
            }
          }
        ]
      });
      return alert.present();
    },
    /** Î°úÎî©Ï∞Ω **/
    async showLoading() {
      this.loading = await this.loadingController.create({
        message: 'Loading...',
        duration: 0
      });

      await this.loading.present();
    },
    async warningAlert(message) {
      const alert = await this.alertController.create({
        header: '',
        subHeader: '',
        message: message,
        buttons: ['OK']
      });
      return alert.present();
    },
    async presentAlertConfirm(item) {
      const alert = await this.alertController.create({
        // cssClass: 'my-custom-class',
        header: '( ' + item.nick + ' ) ÎãòÏùÑ Ï∞®Îã®ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        message:
          'Ïù¥ ÏÇ¨Ïö©ÏûêÏùò Î©îÏãúÏßÄÎ•º Ï±ÑÌåÖÏóêÏÑú Îçî Ïù¥ÏÉÅ Î≥¥ÏßÄ ÏïäÏäµÎãàÎã§. Í≥ÑÏÜç ÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
        buttons: [
          {
            text: 'Ï∑®ÏÜå',
            role: 'cancel',
            cssClass: 'secondary',
            handler: () => {}
          },
          {
            text: 'Ï∞®Îã®',
            handler: () => {
              /** Ï∞®Îã®ÌïòÍ∏∞ **/
              getData({
                url: '/blockByUserInfo',
                param: { targetUserKey: item.userKey },
                then: (data) => {
                  this.warningAlert(data.message);
                  // Í∏∞Ï°¥ Î©îÏÑ∏ÏßÄ Ï§ë Ï∞®Îã®ÏÇ¨Ïö©ÏûêÏùò Î©îÏÑ∏ÏßÄ spliceÏ≤òÎ¶¨
                  for (
                    let i = 0;
                    this.$store.state.messageList.length > i;
                    i++
                  ) {
                    if (
                      this.$store.state.messageList[i].regUserKey ==
                      item.userKey
                    ) {
                      this.$store.state.messageList.splice(i + 1, 1);
                    }
                  }
                }
              });
            }
          }
        ]
      });
      return alert.present();
    }
  }
};
</script>

<style lang="scss" scoped>
* {
  user-select: text !important;
  -webkit-user-select: text !important;
}

.important-height {
  height: 2000px;
}

.message-talk-info {
  ion-item {
    --padding-start: 0;
    --inner-padding-end: 0;

    ion-label {
      margin-right: 10px;
    }

    ion-toggle {
      padding-left: 0;
    }
  }
}

.custom-fixed {
  position: fixed;
  display: flex;
  align-items: center;
  top: 65px;
  right: 15px;
  z-index: 1000;
  padding: 3px 15px 3px 3px;
  background: rgba(0, 0, 0, 0.9);
  border-radius: 25px;
}

.alert-button-block {
  color: red !important;
}
</style>
