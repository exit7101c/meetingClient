{"version":3,"file":"js/4658-legacy.1d476b2e.js","mappings":"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","sources":["webpack://navy/./src/assets/js/MarkerClustering.js"],"sourcesContent":["/**\n * Copyright 2016 NAVER Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * 마커 클러스터링을 정의합니다.\n * @param {Object} options 마커 클러스터링 옵션\n */\nexport var MarkerClustering = function(options) {\n  // 기본 값입니다.\n  this.DEFAULT_OPTIONS = {\n    // 클러스터 마커를 올릴 지도입니다.\n    map: null,\n    // 클러스터 마커를 구성할 마커입니다.\n    markers: [],\n    // 클러스터 마커 클릭 시 줌 동작 여부입니다.\n    disableClickZoom: true,\n    // 클러스터를 구성할 최소 마커 수입니다.\n    minClusterSize: 2,\n    // 클러스터 마커로 표현할 최대 줌 레벨입니다. 해당 줌 레벨보다 높으면, 클러스터를 구성하고 있는 마커를 노출합니다.\n    maxZoom: 13,\n    // 클러스터를 구성할 그리드 크기입니다. 단위는 픽셀입니다.\n    gridSize: 100,\n    // 클러스터 마커의 아이콘입니다. NAVER Maps JavaScript API v3에서 제공하는 아이콘, 심볼, HTML 마커 유형을 모두 사용할 수 있습니다.\n    icons: [],\n    // 클러스터 마커의 아이콘 배열에서 어떤 아이콘을 선택할 것인지 인덱스를 결정합니다.\n    indexGenerator: [10, 100, 200, 500, 1000],\n    // 클러스터 마커의 위치를 클러스터를 구성하고 있는 마커의 평균 좌표로 할 것인지 여부입니다.\n    averageCenter: false,\n    // 클러스터 마커를 갱신할 때 호출하는 콜백함수입니다. 이 함수를 통해 클러스터 마커에 개수를 표현하는 등의 엘리먼트를 조작할 수 있습니다.\n    stylingFunction: function() {}\n  };\n\n  this._clusters = [];\n\n  this._mapRelations = null;\n  this._markerRelations = [];\n\n  this.setOptions(naver.maps.Util.extend({}, this.DEFAULT_OPTIONS, options), true);\n  this.setMap(options.map || null);\n};\n\nnaver.maps.Util.ClassExtend(MarkerClustering, naver.maps.OverlayView, {\n  onAdd: function() {\n    var map = this.getMap();\n\n    this._mapRelations = naver.maps.Event.addListener(map, 'idle', naver.maps.Util.bind(this._onIdle, this));\n\n    if (this.getMarkers().length > 0) {\n      this._createClusters();\n      this._updateClusters();\n    }\n  },\n\n  draw: naver.maps.Util.noop,\n\n  onRemove: function() {\n    naver.maps.Event.removeListener(this._mapRelation);\n\n    this._clearClusters();\n\n    this._geoTree = null;\n    this._mapRelation = null;\n  },\n\n  /**\n   * 마커 클러스터링 옵션을 설정합니다. 설정한 옵션만 반영됩니다.\n   * @param {Object | string} newOptions 옵션\n   */\n  setOptions: function(newOptions) {\n    var _this = this;\n\n    if (typeof newOptions === 'string') {\n      var key = newOptions,\n        value = arguments[1];\n\n      _this.set(key, value);\n    } else {\n      var isFirst = arguments[1];\n\n      naver.maps.Util.forEach(newOptions, function(value, key) {\n        if (key !== 'map') {\n          _this.set(key, value);\n        }\n      });\n\n      if (newOptions.map && !isFirst) {\n        _this.setMap(newOptions.map);\n      }\n    }\n  },\n\n  /**\n   * 마커 클러스터링 옵션을 반환합니다. 특정 옵션 이름을 지정하지 않으면, 모든 옵션을 반환합니다.\n   * @param {string} key 반환받을 옵션 이름\n   * @return {Any} 옵션\n   */\n  getOptions: function(key) {\n    var _this = this,\n      options = {};\n\n    if (key !== undefined) {\n      return _this.get(key);\n    } else {\n      naver.maps.Util.forEach(_this.DEFAULT_OPTIONS, function(value, key) {\n        options[key] = _this.get(key);\n      });\n\n      return options;\n    }\n  },\n\n  /**\n   * 클러스터를 구성하는 최소 마커 수를 반환합니다.\n   * @return {number} 클러스터를 구성하는 최소 마커 수\n   */\n  getMinClusterSize: function() {\n    return this.getOptions('minClusterSize');\n  },\n\n  /**\n   * 클러스터를 구성하는 최소 마커 수를 설정합니다.\n   * @param {number} size 클러스터를 구성하는 최소 마커 수\n   */\n  setMinClusterSize: function(size) {\n    this.setOptions('minClusterSize', size);\n  },\n\n  /**\n   * 클러스터 마커를 노출할 최대 줌 레벨을 반환합니다.\n   * @return {number} 클러스터 마커를 노출할 최대 줌 레벨\n   */\n  getMaxZoom: function() {\n    return this.getOptions('maxZoom');\n  },\n\n  /**\n   * 클러스터 마커를 노출할 최대 줌 레벨을 설정합니다.\n   * @param {number} zoom 클러스터 마커를 노출할 최대 줌 레벨\n   */\n  setMaxZoom: function(zoom) {\n    this.setOptions('maxZoom', zoom);\n  },\n\n  /**\n   * 클러스터를 구성할 그리드 크기를 반환합니다. 단위는 픽셀입니다.\n   * @return {number} 클러스터를 구성할 그리드 크기\n   */\n  getGridSize: function() {\n    return this.getOptions('gridSize');\n  },\n\n  /**\n   * 클러스터를 구성할 그리드 크기를 설정합니다. 단위는 픽셀입니다.\n   * @param {number} size 클러스터를 구성할 그리드 크기\n   */\n  setGridSize: function(size) {\n    this.setOptions('gridSize', size);\n  },\n\n  /**\n   * 클러스터 마커의 아이콘을 결정하는 인덱스 생성기를 반환합니다.\n   * @return {Array | Function} 인덱스 생성기\n   */\n  getIndexGenerator: function() {\n    return this.getOptions('indexGenerator');\n  },\n\n  /**\n   * 클러스터 마커의 아이콘을 결정하는 인덱스 생성기를 설정합니다.\n   * @param {Array | Function} indexGenerator 인덱스 생성기\n   */\n  setIndexGenerator: function(indexGenerator) {\n    this.setOptions('indexGenerator', indexGenerator);\n  },\n\n  /**\n   * 클러스터로 구성할 마커를 반환합니다.\n   * @return {Array.<naver.maps.Marker>} 클러스터로 구성할 마커\n   */\n  getMarkers: function() {\n    return this.getOptions('markers');\n  },\n\n  /**\n   * 클러스터로 구성할 마커를 설정합니다.\n   * @param {Array.<naver.maps.Marker>} markers 클러스터로 구성할 마커\n   */\n  setMarkers: function(markers) {\n    this.setOptions('markers', markers);\n  },\n\n  /**\n   * 클러스터 마커 아이콘을 반환합니다.\n   * @return {Array.<naver.maps.Marker~ImageIcon | naver.maps.Marker~SymbolIcon | naver.maps.Marker~HtmlIcon>} 클러스터 마커 아이콘\n   */\n  getIcons: function() {\n    return this.getOptions('icons');\n  },\n\n  /**\n   * 클러스터 마커 아이콘을 설정합니다.\n   * @param {Array.<naver.maps.Marker~ImageIcon | naver.maps.Marker~SymbolIcon | naver.maps.Marker~HtmlIcon>} icons 클러스터 마커 아이콘\n   */\n  setIcons: function(icons) {\n    this.setOptions('icons', icons);\n  },\n\n  /**\n   * 클러스터 마커의 엘리먼트를 조작할 수 있는 스타일링 함수를 반환합니다.\n   * @return {Funxtion} 콜백함수\n   */\n  getStylingFunction: function() {\n    return this.getOptions('stylingFunction');\n  },\n\n  /**\n   * 클러스터 마커의 엘리먼트를 조작할 수 있는 스타일링 함수를 설정합니다.\n   * @param {Function} func 콜백함수\n   */\n  setStylingFunction: function(func) {\n    this.setOptions('stylingFunction', func);\n  },\n\n  /**\n   * 클러스터 마커를 클릭했을 때 줌 동작 수행 여부를 반환합니다.\n   * @return {boolean} 줌 동작 수행 여부\n   */\n  getDisableClickZoom: function() {\n    return this.getOptions('disableClickZoom');\n  },\n\n  /**\n   * 클러스터 마커를 클릭했을 때 줌 동작 수행 여부를 설정합니다.\n   * @param {boolean} flag 줌 동작 수행 여부\n   */\n  setDisableClickZoom: function(flag) {\n    this.setOptions('disableClickZoom', flag);\n  },\n\n  /**\n   * 클러스터 마커의 위치를 클러스터를 구성하고 있는 마커의 평균 좌표로 할 것인지 여부를 반환합니다.\n   * @return {boolean} 평균 좌표로 클러스터링 여부\n   */\n  getAverageCenter: function() {\n    return this.getOptions('averageCenter');\n  },\n\n  /**\n   * 클러스터 마커의 위치를 클러스터를 구성하고 있는 마커의 평균 좌표로 할 것인지 여부를 설정합니다.\n   * @param {boolean} averageCenter 평균 좌표로 클러스터링 여부\n   */\n  setAverageCenter: function(averageCenter) {\n    this.setOptions('averageCenter', averageCenter);\n  },\n\n  // KVO 이벤트 핸들러\n  changed: function(key, value) {\n    if (!this.getMap()) return;\n\n    switch (key) {\n      case 'marker':\n      case 'minClusterSize':\n      case 'gridSize':\n      case 'averageCenter':\n        this._redraw();\n        break;\n      case 'indexGenerator':\n      case 'icons':\n        this._clusters.forEach(function(cluster) {\n          cluster.updateIcon();\n        });\n        break;\n      case 'maxZoom':\n        this._clusters.forEach(function(cluster) {\n          if (cluster.getCount() > 1) {\n            cluster.checkByZoomAndMinClusterSize();\n          }\n        });\n        break;\n      case 'stylingFunction':\n        this._clusters.forEach(function(cluster) {\n          cluster.updateCount();\n        });\n        break;\n      case 'disableClickZoom':\n        var exec = 'enableClickZoom';\n\n        if (value) {\n          exec = 'disableClickZoom';\n        }\n\n        this._clusters.forEach(function(cluster) {\n          cluster[exec]();\n        });\n        break;\n    }\n  },\n\n  /**\n   * 현재 지도 경계 영역 내의 마커에 대해 클러스터를 생성합니다.\n   * @private\n   */\n  _createClusters: function() {\n    var map = this.getMap();\n\n    if (!map) return;\n\n    var bounds = map.getBounds(),\n      markers = this.getMarkers();\n\n    for (var i = 0, ii = markers.length; i < ii; i++) {\n      var marker = markers[i],\n        position = marker.getPosition();\n\n      if (!bounds.hasLatLng(position)) continue;\n\n      var\tclosestCluster = this._getClosestCluster(position);\n\n      closestCluster.addMarker(marker);\n\n      this._markerRelations.push(naver.maps.Event.addListener(marker, 'dragend', naver.maps.Util.bind(this._onDragEnd, this)));\n    }\n  },\n\n  /**\n   * 클러스터의 아이콘, 텍스트를 갱신합니다.\n   * @private\n   */\n  _updateClusters: function() {\n    var clusters = this._clusters;\n\n    for (var i = 0, ii = clusters.length; i < ii; i++) {\n      clusters[i].updateCluster();\n    }\n  },\n\n  /**\n   * 클러스터를 모두 제거합니다.\n   * @private\n   */\n  _clearClusters: function() {\n    var clusters = this._clusters;\n\n    for (var i = 0, ii = clusters.length; i < ii; i++) {\n      clusters[i].destroy();\n    }\n\n    naver.maps.Event.removeListener(this._markerRelations);\n\n    this._markerRelations = [];\n    this._clusters = [];\n  },\n\n  /**\n   * 생성된 클러스터를 모두 제거하고, 다시 생성합니다.\n   * @private\n   */\n  _redraw: function() {\n    this._clearClusters();\n    this._createClusters();\n    this._updateClusters();\n  },\n\n  /**\n   * 전달된 위/경도에서 가장 가까운 클러스터를 반환합니다. 없으면 새로 클러스터를 생성해 반환합니다.\n   * @param {naver.maps.LatLng} position 위/경도\n   * @return {Cluster} 클러스터\n   */\n  _getClosestCluster: function(position) {\n    var proj = this.getProjection(),\n      clusters = this._clusters,\n      closestCluster = null,\n      distance = Infinity;\n\n    for (var i = 0, ii = clusters.length; i < ii; i++) {\n      var cluster = clusters[i],\n        center = cluster.getCenter();\n\n      if (cluster.isInBounds(position)) {\n        var delta = proj.getDistance(center, position);\n\n        if (delta < distance) {\n          distance = delta;\n          closestCluster = cluster;\n        }\n      }\n    }\n\n    if (!closestCluster) {\n      closestCluster = new Cluster(this);\n      this._clusters.push(closestCluster);\n    }\n\n    return closestCluster;\n  },\n\n  /**\n   * 지도의 Idle 상태 이벤트 핸들러입니다.\n   */\n  _onIdle: function() {\n    this._redraw();\n  },\n\n  /**\n   * 각 마커의 드래그 종료 이벤트 핸들러입니다.\n   */\n  _onDragEnd: function() {\n    this._redraw();\n  }\n});\n\n/**\n * 마커를 가지고 있는 클러스터를 정의합니다.\n * @param {MarkerClustering} markerClusterer\n */\nvar Cluster = function(markerClusterer) {\n  this._clusterCenter = null;\n  this._clusterBounds = null;\n  this._clusterMarker = null;\n  this._relation = null;\n\n  this._clusterMember = [];\n\n  this._markerClusterer = markerClusterer;\n};\n\nCluster.prototype = {\n  constructor: Cluster,\n\n  /**\n   * 클러스터에 마커를 추가합니다.\n   * @param {naver.maps.Marker} marker 클러스터에 추가할 마커\n   */\n  addMarker: function(marker) {\n    if (this._isMember(marker)) return;\n\n    if (!this._clusterCenter) {\n      var position = marker.getPosition();\n\n      this._clusterCenter = position;\n      this._clusterBounds = this._calcBounds(position);\n    }\n\n    this._clusterMember.push(marker);\n  },\n\n  /**\n   * 클러스터를 제거합니다.\n   */\n  destroy: function() {\n    naver.maps.Event.removeListener(this._relation);\n\n    var members = this._clusterMember;\n\n    for (var i = 0, ii = members.length; i < ii; i++) {\n      members[i].setMap(null);\n    }\n\n    this._clusterMarker.setMap(null);\n\n    this._clusterMarker = null;\n    this._clusterCenter = null;\n    this._clusterBounds = null;\n    this._relation = null;\n\n    this._clusterMember = [];\n  },\n\n  /**\n   * 클러스터 중심점을 반환합니다.\n   * @return {naver.maps.LatLng} 클러스터 중심점\n   */\n  getCenter: function() {\n    return this._clusterCenter;\n  },\n\n  /**\n   * 클러스터 경계 영역을 반환합니다.\n   * @return {naver.maps.LatLngBounds} 클러스터 경계 영역\n   */\n  getBounds: function() {\n    return this._clusterBounds;\n  },\n\n  /**\n   * 클러스터를 구성하는 마커 수를 반환합니다.\n   * @return {number} 클러스터를 구성하는 마커 수\n   */\n  getCount: function() {\n    return this._clusterMember.length;\n  },\n\n  /**\n   * 현재의 클러스터 멤버 마커 객체를 반환합니다.\n   * @return {naver.maps.Marker[]} 클러스터를 구성하는 마커 객체 집합\n   */\n  getClusterMember: function() {\n    return this._clusterMember;\n  },\n\n  /**\n   * 전달된 위/경도가 클러스터 경계 영역 내에 있는지 여부를 반환합니다.\n   * @param {naver.maps.LatLng} latlng 위/경도\n   * @return {boolean} 클러스터 경계 영역 내의 위치 여부\n   */\n  isInBounds: function(latlng) {\n    return this._clusterBounds && this._clusterBounds.hasLatLng(latlng);\n  },\n\n  /**\n   * 클러스터 마커 클릭 시 줌 동작을 수행하도록 합니다.\n   */\n  enableClickZoom: function() {\n    if (this._relation) return;\n\n    var map = this._markerClusterer.getMap();\n\n    this._relation = naver.maps.Event.addListener(this._clusterMarker, 'click', naver.maps.Util.bind(function(e) {\n      map.morph(e.coord, map.getZoom() + 1);\n    }, this));\n  },\n\n  /**\n   * 클러스터 마커 클릭 시 줌 동작을 수행하지 않도록 합니다.\n   */\n  disableClickZoom: function() {\n    if (!this._relation) return;\n\n    naver.maps.Event.removeListener(this._relation);\n    this._relation = null;\n  },\n\n  /**\n   * 클러스터 마커가 없으면 클러스터 마커를 생성하고, 클러스터 마커를 갱신합니다.\n   * - 클러스터 마커 아이콘\n   * - 마커 개수\n   * - 클러스터 마커 노출 여부\n   */\n  updateCluster: function() {\n    if (!this._clusterMarker) {\n      var position;\n\n      if (this._markerClusterer.getAverageCenter()) {\n        position = this._calcAverageCenter(this._clusterMember);\n      } else {\n        position = this._clusterCenter;\n      }\n\n      this._clusterMarker = new naver.maps.Marker({\n        position: position,\n        map: this._markerClusterer.getMap()\n      });\n\n      if (!this._markerClusterer.getDisableClickZoom()) {\n        this.enableClickZoom();\n      }\n    }\n\n    this.updateIcon();\n    this.updateCount();\n\n    this.checkByZoomAndMinClusterSize();\n  },\n\n  /**\n   * 조건에 따라 클러스터 마커를 노출하거나, 노출하지 않습니다.\n   */\n  checkByZoomAndMinClusterSize: function() {\n    var clusterer = this._markerClusterer,\n      minClusterSize = clusterer.getMinClusterSize(),\n      maxZoom = clusterer.getMaxZoom(),\n      currentZoom = clusterer.getMap().getZoom();\n\n    if (this.getCount() < minClusterSize) {\n      this._showMember();\n    } else {\n      this._hideMember();\n\n      if (maxZoom <= currentZoom) {\n        this._showMember();\n      }\n    }\n  },\n\n  /**\n   * 클러스터를 구성하는 마커 수를 갱신합니다.\n   */\n  updateCount: function() {\n    var stylingFunction = this._markerClusterer.getStylingFunction();\n\n    stylingFunction && stylingFunction(this._clusterMarker, this.getCount());\n  },\n\n  /**\n   * 클러스터 마커 아이콘을 갱신합니다.\n   */\n  updateIcon: function() {\n    var count = this.getCount(),\n      index = this._getIndex(count),\n      icons = this._markerClusterer.getIcons();\n\n    index = Math.max(index, 0);\n    index = Math.min(index, icons.length - 1);\n\n    this._clusterMarker.setIcon(icons[index]);\n  },\n\n  /**\n   * 클러스터를 구성하는 마커를 노출합니다. 이때에는 클러스터 마커를 노출하지 않습니다.\n   * @private\n   */\n  _showMember: function() {\n    var map = this._markerClusterer.getMap(),\n      marker = this._clusterMarker,\n      members = this._clusterMember;\n\n    for (var i = 0, ii = members.length; i < ii; i++) {\n      members[i].setMap(map);\n    }\n\n    if (marker) {\n      marker.setMap(null);\n    }\n  },\n\n  /**\n   * 클러스터를 구성하는 마커를 노출하지 않습니다. 이때에는 클러스터 마커를 노출합니다.\n   * @private\n   */\n  _hideMember: function() {\n    var map = this._markerClusterer.getMap(),\n      marker = this._clusterMarker,\n      members = this._clusterMember;\n\n    for (var i = 0, ii = members.length; i < ii; i++) {\n      members[i].setMap(null);\n    }\n\n    if (marker && !marker.getMap()) {\n      marker.setMap(map);\n    }\n  },\n\n  /**\n   * 전달된 위/경도를 중심으로 그리드 크기만큼 확장한 클러스터 경계 영역을 반환합니다.\n   * @param {naver.maps.LatLng} position 위/경도\n   * @return {naver.maps.LatLngBounds} 클러스터 경계 영역\n   * @private\n   */\n  _calcBounds: function(position) {\n    var map = this._markerClusterer.getMap(),\n      bounds = new naver.maps.LatLngBounds(position.clone(), position.clone()),\n      mapBounds = map.getBounds(),\n      proj = map.getProjection(),\n      map_max_px = proj.fromCoordToOffset(mapBounds.getNE()),\n      map_min_px = proj.fromCoordToOffset(mapBounds.getSW()),\n      max_px = proj.fromCoordToOffset(bounds.getNE()),\n      min_px = proj.fromCoordToOffset(bounds.getSW()),\n      gridSize = this._markerClusterer.getGridSize() / 2;\n\n    max_px.add(gridSize, -gridSize);\n    min_px.add(-gridSize, gridSize);\n\n    var max_px_x = Math.min(map_max_px.x, max_px.x),\n      max_px_y = Math.max(map_max_px.y, max_px.y),\n      min_px_x = Math.max(map_min_px.x, min_px.x),\n      min_px_y = Math.min(map_min_px.y, min_px.y),\n      newMax = proj.fromOffsetToCoord(new naver.maps.Point(max_px_x, max_px_y)),\n      newMin = proj.fromOffsetToCoord(new naver.maps.Point(min_px_x, min_px_y));\n\n    return new naver.maps.LatLngBounds(newMin, newMax);\n  },\n\n  /**\n   * 클러스터를 구성하는 마커 수에 따라 노출할 아이콘을 결정하기 위한 인덱스를 반환합니다.\n   * @param {number} count 클러스터를 구성하는 마커 수\n   * @return {number} 인덱스\n   * @private\n   */\n  _getIndex: function(count) {\n    var indexGenerator = this._markerClusterer.getIndexGenerator();\n\n    if (naver.maps.Util.isFunction(indexGenerator)) {\n      return indexGenerator(count);\n    } else if (naver.maps.Util.isArray(indexGenerator)) {\n      var index = 0;\n\n      for (var i = index, ii = indexGenerator.length; i < ii; i++) {\n        var factor = indexGenerator[i];\n\n        if (count < factor) break;\n\n        index++;\n      }\n\n      return index;\n    }\n  },\n\n  /**\n   * 전달된 마커가 이미 클러스터에 속해 있는지 여부를 반환합니다.\n   * @param {naver.maps.Marker} marker 마커\n   * @return {boolean} 클러스터에 속해 있는지 여부\n   * @private\n   */\n  _isMember: function(marker) {\n    return this._clusterMember.indexOf(marker) !== -1;\n  },\n\n  /**\n   * 전달된 마커들의 중심 좌표를 반환합니다.\n   * @param {Array.<naver.maps.Marker>} markers 마커 배열\n   * @return {naver.maps.Point} 마커들의 중심 좌표\n   * @private\n   */\n  _calcAverageCenter: function(markers) {\n    var numberOfMarkers = markers.length;\n    var averageCenter = [0, 0];\n\n    for (var i = 0; i < numberOfMarkers; i++) {\n      averageCenter[0] += markers[i].position.x;\n      averageCenter[1] += markers[i].position.y;\n    }\n\n    averageCenter[0] /= numberOfMarkers;\n    averageCenter[1] /= numberOfMarkers;\n\n    return new naver.maps.Point(averageCenter[0], averageCenter[1]);\n  }\n\n\n};"],"names":["MarkerClustering","options","this","DEFAULT_OPTIONS","map","markers","disableClickZoom","minClusterSize","maxZoom","gridSize","icons","indexGenerator","averageCenter","stylingFunction","_clusters","_mapRelations","_markerRelations","setOptions","naver","maps","Util","extend","setMap","ClassExtend","OverlayView","onAdd","getMap","Event","addListener","bind","_onIdle","getMarkers","length","_createClusters","_updateClusters","draw","noop","onRemove","removeListener","_mapRelation","_clearClusters","_geoTree","newOptions","_this","key","value","arguments","set","isFirst","forEach","getOptions","undefined","get","getMinClusterSize","setMinClusterSize","size","getMaxZoom","setMaxZoom","zoom","getGridSize","setGridSize","getIndexGenerator","setIndexGenerator","setMarkers","getIcons","setIcons","getStylingFunction","setStylingFunction","func","getDisableClickZoom","setDisableClickZoom","flag","getAverageCenter","setAverageCenter","changed","_redraw","cluster","updateIcon","getCount","checkByZoomAndMinClusterSize","updateCount","exec","bounds","getBounds","i","ii","marker","position","getPosition","hasLatLng","closestCluster","_getClosestCluster","addMarker","push","_onDragEnd","clusters","updateCluster","destroy","proj","getProjection","distance","Infinity","center","getCenter","isInBounds","delta","getDistance","Cluster","markerClusterer","_clusterCenter","_clusterBounds","_clusterMarker","_relation","_clusterMember","_markerClusterer","prototype","constructor","_isMember","_calcBounds","members","getClusterMember","latlng","enableClickZoom","e","morph","coord","getZoom","_calcAverageCenter","Marker","clusterer","currentZoom","_showMember","_hideMember","count","index","_getIndex","Math","max","min","setIcon","LatLngBounds","clone","mapBounds","map_max_px","fromCoordToOffset","getNE","map_min_px","getSW","max_px","min_px","add","max_px_x","x","max_px_y","y","min_px_x","min_px_y","newMax","fromOffsetToCoord","Point","newMin","isFunction","isArray","factor","indexOf","numberOfMarkers"],"sourceRoot":""}